<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENT - Syntactic Analysis Assistant</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* ===========================================
           VARIABLES AND RESET
           =========================================== */
        :root {
            --btn-primary-bg: #374151;
            --btn-primary-bg-hover: #1f2937;
            --btn-primary-text: #ffffff;
            --btn-outline-bg: #ffffff;
            --btn-outline-border: #d1d5db;
            --btn-outline-border-hover: #cbd5e1;
            --btn-outline-text: #374151;
            --btn-exercise-border: #a78bfa;
            --btn-exercise-text: #5b21b6;
            --btn-exercise-bg-hover: #f5f3ff;
            --btn-success-bg: #047857;
            --btn-success-bg-hover: #065f46;
        }

        * { box-sizing: border-box; }
        
        body { 
            margin: 0; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background-color: #f3f4f6; 
            min-height: 100vh; 
            color: #374151; 
        }

        /* ===========================================
           MAIN LAYOUT
           =========================================== */
        .container { 
            position: relative;
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px 24px 32px; 
        }

        .header-logo-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-logo {
            max-width: 380px;
            width: 100%;
            height: auto;
        }

        /* ===========================================
        LANGUAGE SELECTOR
        =========================================== */
        .language-selector {
            position: absolute;
            top: 20px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        .language-selector a {
            display: flex;
            align-items: center;
        }

        .language-flag {
            height: 28px;
            width: auto;
            border-radius: 3px;
            transition: opacity 0.2s ease, transform 0.2s ease;
            display: block;
        }

        .language-flag.active {
            opacity: 1;
            cursor: default;
        }

        .language-flag.inactive {
            opacity: 0.7;
            cursor: pointer;
        }

        .language-flag.inactive:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .input-section { 
            background: white; 
            border-radius: 8px; 
            padding: 24px; 
            margin-bottom: 24px; 
            border: 1px solid #e5e7eb; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
        }

        .input-row { 
            display: flex; 
            gap: 12px; 
            align-items: center; 
            flex-wrap: wrap; 
        }

        .input-row input[type="text"] { 
            flex: 1; 
            padding: 12px 16px; 
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            font-size: 15px; 
            min-width: 200px; 
        }

        /* ===========================================
           BUTTONS
           =========================================== */
        .btn {
            padding: 10px 20px;
            border: 1px solid transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            line-height: 1;
            user-select: none;
        }

        .btn:active { transform: translateY(1px); }
        .btn:focus-visible { outline: 3px solid rgba(59,130,246,.35); outline-offset: 2px; }

        .btn-primary {
            background-color: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .btn-primary:hover { 
            background-color: #111827; 
            box-shadow: 0 6px 16px rgba(17, 24, 39, 0.35);
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: var(--btn-outline-bg);
            border-color: var(--btn-outline-border);
            color: var(--btn-outline-text);
        }
        .btn-outline:hover {
            background-color: #e5e7eb;
            border-color: #6b7280;
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }

        .btn-exercise {
            background-color: #ffffff;
            border-color: var(--btn-exercise-border);
            color: var(--btn-exercise-text);
        }
        .btn-exercise:hover {
            background-color: #ddd6fe;
            border-color: #7c3aed;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
            transform: translateY(-2px);
        }

        .btn-success {
            background-color: var(--btn-success-bg);
            color: white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .btn-success:hover { 
            background-color: #065f46; 
            box-shadow: 0 6px 16px rgba(4, 120, 87, 0.4);
            transform: translateY(-2px);
        }

        .btn-danger-soft { 
            background-color: #fff1f2; 
            color: #991b1b; 
            border: 1px solid #fee2e2; 
            padding: 4px 10px; 
            font-size: 11px; 
            cursor: pointer; 
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        .btn-danger-soft:hover {
            background-color: #fecaca;
            border-color: #f87171;
            box-shadow: 0 3px 10px rgba(239, 68, 68, 0.25);
        }

        .btn-new-analysis {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.35);
            position: relative;
            overflow: hidden;
        }
        .btn-new-analysis::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        .btn-new-analysis:hover {
            background: linear-gradient(135deg, #ea580c 0%, #c2410c 100%);
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.5);
            transform: translateY(-2px);
        }
        .btn-new-analysis:hover::before {
            left: 100%;
        }

        .btn-icon {
            padding: 10px 12px;
            min-width: 42px;
        }
        .btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .btn-separator {
            width: 1px;
            height: 24px;
            background-color: #d1d5db;
            margin: 0 4px;
            align-self: center;
        }

        /* ===========================================
           SYNTAX TREE
           =========================================== */
        .tree-container { 
            background: white; 
            border-radius: 8px; 
            padding: 40px; 
            border: 1px solid #e5e7eb; 
            overflow-x: auto; 
            min-height: 450px; 
        }

        .tree-wrapper { 
            display: flex; 
            justify-content: flex-start; 
            padding: 20px 0; 
            position: relative; 
            width: fit-content; 
            min-width: 100%; 
            margin: 0 auto; 
        }

        .children-container { 
            display: flex; 
            justify-content: center; 
            align-items: flex-start; 
            position: relative; 
        }

        .child-branch { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            position: relative; 
            padding-top: 24px; 
        }

        .child-branch::before, 
        .child-branch::after { 
            content: ""; 
            position: absolute; 
            top: 0; 
            width: 50%; 
            height: 24px; 
            border-top: 1.5px solid #6b7280; 
        }
        .child-branch::before { right: 50%; }
        .child-branch::after { left: 50%; }
        .child-branch:first-child::before { border-top: none; }
        .child-branch:last-child::after { border-top: none; }

        .v-line-stem { 
            width: 1.5px; 
            height: 24px; 
            background-color: #6b7280; 
            position: absolute; 
            top: 0; 
            left: 50%; 
            transform: translateX(-50%); 
        }

        /* Technical mode (tree) */
        .technical-mode .child-branch::before, 
        .technical-mode .child-branch::after { display: none !important; }
        .technical-mode .child-branch { padding-top: 60px; }

        /* ===========================================
           NODES
           =========================================== */
        .node-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            position: relative; 
            z-index: 2; 
            margin: 0 10px; 
            width: fit-content; 
        }

        .connector-v { 
            width: 1.5px; 
            background-color: #6b7280; 
            margin: 0 auto; 
        }

        .node-box { 
            padding: 12px 24px; 
            border: 1.5px solid #4b5563; 
            border-radius: 4px; 
            background-color: white; 
            font-size: 16px; 
            color: #111827; 
            min-width: 100px; 
            text-align: center; 
            position: relative; 
        }

        .node-box.can-divide { 
            border-color: #374151; 
            background-color: #f0f7ff; 
            cursor: pointer; 
        }

        .nucleus-node > .label-wrap .label-input,
        .nucleus-node > .label-wrap .label-display,
        .nucleus-node .node-box,
        .nucleus-node > div > .label-wrap .label-input,
        .nucleus-node > div > .label-wrap .label-display { 
            font-weight: bold; 
        }

        /* ===========================================
           LABELS
           =========================================== */
        .label-input { 
            width: 95px; 
            text-align: center; 
            border: 1px dashed #d1d5db; 
            border-radius: 4px; 
            padding: 4px; 
            font-size: 11px; 
            background: transparent; 
            color: #4b5563; 
            font-family: Arial, sans-serif; 
        }

        .label-input.has-value-top, 
        .label-input.has-value-bottom { 
            background-color: #f1f5f9; 
            border: 1px solid #cbd5e1; 
            color: #334155; 
        }

        .label-input.label-top { text-transform: uppercase; }

        .label-display {
            min-width: 95px;
            text-align: center;
            border: 1px dashed #d1d5db;
            border-radius: 4px;
            padding: 4px;
            font-size: 11px;
            background: transparent;
            color: #4b5563;
            font-family: Arial, sans-serif;
            cursor: text;
            display: inline-block;
        }

        .label-display.has-value {
            background-color: #f1f5f9;
            border: 1px solid #cbd5e1;
            color: #334155;
        }

        .label-display.label-top {
            text-transform: uppercase;
        }

        .label-display:hover {
            border-color: #93c5fd;
        }

        .label-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .split-toggle-btn {
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #6b7280;
            font-size: 11px;
            line-height: 14px;
            padding: 0;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .label-wrap:hover .split-toggle-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .split-toggle-btn:hover {
            color: #374151;
            border-color: #93c5fd;
        }

        /* ===========================================
           LABEL SELECTOR DROPDOWN
           =========================================== */
        .label-with-dropdown {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .dropdown-trigger {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #c7d2fe;
            background: #eef2ff;
            color: #6366f1;
            font-size: 9px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        .label-with-dropdown:hover .dropdown-trigger {
            opacity: 1;
            pointer-events: auto;
        }

        .dropdown-trigger:hover {
            background: #c7d2fe;
            border-color: #818cf8;
            color: #4338ca;
        }

        .dropdown-trigger:active {
            background: #a5b4fc;
        }

        .label-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            min-width: 240px;
            max-height: 320px;
            overflow-y: auto;
            margin-top: 4px;
        }

        .dropdown-section {
            padding: 4px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .dropdown-section:last-child {
            border-bottom: none;
        }

        .dropdown-section-title {
            padding: 4px 12px;
            font-size: 9px;
            font-weight: 700;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: #f9fafb;
        }

        .dropdown-item {
            padding: 5px 12px;
            font-size: 11px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s ease;
        }

        .dropdown-item:hover {
            background: #f0f7ff;
        }

        .dropdown-item-abbr {
            font-weight: 600;
            min-width: 50px;
            color: #1f2937;
        }

        .dropdown-item-full {
            color: #6b7280;
            font-size: 10px;
        }

        .dropdown-search {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }

        .dropdown-search input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 11px;
            outline: none;
        }

        .dropdown-search input:focus {
            border-color: #93c5fd;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .dropdown-empty {
            padding: 12px;
            color: #9ca3af;
            font-size: 11px;
            text-align: center;
        }

        /* ===========================================
           NODE ACTION BUTTONS
           =========================================== */
        .clear-text-btn { 
            position: absolute; 
            top: -10px; 
            right: -10px; 
            background: #ef4444; 
            color: white; 
            border: none; 
            border-radius: 50%; 
            width: 18px; 
            height: 18px; 
            font-size: 10px; 
            cursor: pointer; 
            display: none; 
            align-items: center; 
            justify-content: center; 
        }
        .node-box:hover .clear-text-btn { display: flex; }

        .add-node-btn {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .node-box:hover .add-node-btn { display: flex; }

        .consolidate-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .node-box:hover .consolidate-btn { display: flex; }

        .nucleus-toggle-btn {
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #6b7280;
            font-size: 11px;
            font-weight: bold;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            align-items: center;
            justify-content: center;
            display: flex;
            transition: opacity 0.15s ease;
        }
        .node-box:hover .nucleus-toggle-btn { 
            opacity: 1; 
            pointer-events: auto; 
        }
        .nucleus-toggle-btn:hover {
            color: #374151;
            border-color: #93c5fd;
            background: #f0f9ff;
            opacity: 1;
            pointer-events: auto;
        }
        .nucleus-toggle-btn.is-nucleus {
            background: #374151;
            color: white;
            border-color: #374151;
        }
        .nucleus-toggle-btn.is-nucleus:hover {
            background: #1f2937;
        }

        
        /* --- Revert division button --- */
        .node-box-row{
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .node-revert-btn{
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translate(2px, -50%);
            z-index: 50;
            pointer-events: auto;
        }

/* ===========================================
           BOTTOM ACTIONS AND INSTRUCTIONS
           =========================================== */
        .bottom-actions { 
            display: flex; 
            justify-content: center; 
            gap: 16px; 
            margin-top: 24px; 
            padding: 20px; 
            background: #f9fafb; 
            border-radius: 8px; 
            border: 1px solid #e5e7eb; 
            flex-wrap: wrap; 
        }

        /* ===========================================
           INSTRUCTIONS PANEL (CARD STYLE)
           =========================================== */
        .instructions-panel {
            margin-top: 32px;
            background: linear-gradient(135deg, #fdfcfb 0%, #f7f6f3 100%);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            overflow: hidden;
        }

        .instructions-header {
            background: #374151;
            color: white;
            padding: 16px 24px;
            font-size: 1.15rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .instructions-header:hover {
            background: #4b5563;
        }

        .instructions-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .instructions-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .instructions-content {
            max-height: 4000px;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .instructions-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1px;
            background: #e5e7eb;
        }

        @media (max-width: 600px) {
            .instructions-grid {
                grid-template-columns: 1fr;
            }
        }

        .instruction-card {
            background: white;
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .instruction-card h4 {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }

        .instruction-card h4 .icon {
            width: 24px;
            height: 24px;
            background: #374151;
            color: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .instruction-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 13px;
            line-height: 1.6;
            color: #6b7280;
        }

        .instruction-card li {
            position: relative;
            padding-left: 16px;
            margin-bottom: 6px;
        }

        .instruction-card li::before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #374151;
            font-weight: bold;
        }

        .instruction-card li:last-child {
            margin-bottom: 0;
        }

        .instruction-card strong {
            color: #374151;
        }

        .instruction-card code {
            display: inline-block;
            background: #f5f4f0;
            padding: 1px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 12px;
            color: #374151;
            border: 1px solid #e8e6e1;
        }

        /* --- Physical Key Style --- */
        .key {
            display: inline-block;
            background: linear-gradient(180deg, #fafafa 0%, #e8e8e8 100%);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: system-ui, sans-serif;
            font-weight: 600;
            color: #374151;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            margin: 0 2px;
        }

        /* --- Shortcut List Cleanup --- */
        .shortcut-list li::before {
            content: none !important;
        }

        .shortcut-list li {
            padding-left: 0 !important;
            margin-bottom: 8px !important;
            color: #4b5563;
        }

        /* ===========================================
           EXERCISE MODE
           =========================================== */
        .exercise-banner {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-left: 6px solid #8b5cf6;
            color: #111827;
            padding: 16px 24px;
            border-radius: 10px;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .exercise-banner-text {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .exercise-banner-icon { font-size: 20px; }
        .exercise-banner h3 { margin: 0; font-size: 16px; color: #111827; }
        .exercise-banner p { margin: 4px 0 0; font-size: 13px; color: #6b7280; }

        .exercise-banner {
            display: flex;
            flex-direction: column; /* Stack title on top and buttons below */
            align-items: center;    /* Centra todo horizontalmente */
            text-align: center;     /* Ensure internal text is centered */
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-top: 4px solid #8b5cf6;
            border-bottom: 4px solid #8b5cf6;
            padding: 24px;
            border-radius: 8px;
            margin-bottom: 24px;
            gap: 20px;
        }

        /* ===========================================
           COMPARISON RESULTS
           =========================================== */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-top: 24px;
        }

        .comparison-panel {
            background: white;
            border-radius: 8px;
            padding: 24px;
            border: 2px solid #e5e7eb;
            overflow-x: auto;
        }
        .comparison-panel.student { border-color: #3b82f6; }
        .comparison-panel.model { border-color: #10b981; }

        .comparison-panel h3 {
            margin: 0 0 16px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .comparison-panel.student h3 { color: #3b82f6; }
        .comparison-panel.model h3 { color: #10b981; }

        .comparison-tree { overflow-x: auto; }

        /* Difference highlighting */
        .node-correct .node-box {
            border-color: #10b981 !important;
            background-color: #ecfdf5 !important;
        }
        .node-incorrect .node-box {
            border-color: #ef4444 !important;
            background-color: #fef2f2 !important;
        }
        .label-correct {
            background-color: #d1fae5 !important;
            border-color: #10b981 !important;
            color: #065f46 !important;
        }
        .label-incorrect {
            background-color: #fee2e2 !important;
            border-color: #ef4444 !important;
            color: #991b1b !important;
        }

        /* Results summary */
        .results-summary {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid #e5e7eb;
        }
        .results-summary h3 { margin: 0 0 16px; color: #374151; }

        .results-stats {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .stat-dot.correct { background-color: #10b981; }
        .stat-dot.incorrect { background-color: #ef4444; }
        .stat-dot.partial { background-color: #f59e0b; }

        /* ===========================================
           POSITION PICKER MODAL
           =========================================== */
        .pos-overlay {
            position: fixed;
            inset: 0;
            background: rgba(17,24,39,.35);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .pos-modal {
            width: min(520px, calc(100vw - 32px));
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,.18);
            padding: 18px 18px 14px;
        }

        .pos-title {
            font-weight: 700;
            color: #111827;
            margin: 0 0 6px;
        }

        .pos-sub {
            margin: 0 0 12px;
            color: #6b7280;
            font-size: 13px;
            line-height: 1.35;
        }

        .pos-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .pos-select {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            background: #fff;
            color: #111827;
        }

        .pos-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 14px;
        }

        /* ===========================================
           FILES MODAL
           =========================================== */
        .files-modal {
            width: min(600px, calc(100vw - 32px));
            max-height: calc(100vh - 64px);
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,.18);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .files-modal-header {
            padding: 18px 20px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .files-modal-title {
            font-weight: 700;
            color: #111827;
            margin: 0 0 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .files-tabs {
            display: flex;
            gap: 0;
        }

        .files-tab {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .files-tab:hover {
            color: #374151;
            background: #f9fafb;
        }

        .files-tab.active {
            color: #374151;
            border-bottom-color: #374151;
        }

        .files-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .files-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .files-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .files-btn-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .files-btn-row .btn {
            flex: 1;
            min-width: 140px;
            justify-content: center;
        }

        /* Example bank */
        .drive-connect-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        .drive-url-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .drive-url-input:focus {
            border-color: #93c5fd;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .drive-url-input::placeholder {
            color: #9ca3af;
        }

        .drive-status {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drive-status.loading {
            background: #f0f9ff;
            color: #0369a1;
            border: 1px solid #bae6fd;
        }

        .drive-status.error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .drive-status.success {
            background: #f0fdf4;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .drive-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #bae6fd;
            border-top-color: #0369a1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .drive-files-list {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            max-height: 300px;
            overflow-y: auto;
        }

        .drive-folder {
            border-bottom: 1px solid #e5e7eb;
        }

        .drive-folder:last-child {
            border-bottom: none;
        }

        .drive-folder-header {
            padding: 10px 14px;
            background: #f9fafb;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s ease;
        }

        .drive-folder-header:hover {
            background: #f3f4f6;
        }

        .drive-folder-toggle {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .drive-folder-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .drive-folder-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .drive-folder-content.collapsed {
            max-height: 0;
        }

        .drive-file-item {
            padding: 10px 14px 10px 28px;
            font-size: 13px;
            color: #374151;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s ease;
        }

        .drive-file-item:last-child {
            border-bottom: none;
        }

        .drive-file-item:hover {
            background: #f0f7ff;
        }

        .drive-file-item.selected {
            background: #eff6ff;
            border-left: 3px solid #3b82f6;
            padding-left: 25px;
        }

        .drive-file-icon {
            font-size: 14px;
        }

        .drive-file-name {
            flex: 1;
        }

        /* Load options */
        .drive-load-options {
            padding: 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .drive-load-options .btn {
            min-width: 160px;
        }

        .files-modal-footer {
            padding: 14px 20px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
        }

        .drive-root-files {
            padding: 4px 0;
        }

        .files-help-text {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
            line-height: 1.5;
        }

        .files-help-text code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* ===========================================
           FOOTER
           =========================================== */
        .footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 14px;
        }
        .footer strong { color: #374151; }
        .footer a { color: #374151; text-decoration: none; }
        .footer a:hover { text-decoration: underline; }
        .footer img { 
            opacity: 0.8; 
            transition: opacity 0.2s;
            display: block;
            margin: 10px auto 0;
            height: 31px; 
            width: auto;
        }
        .footer img:hover { opacity: 1; }

        /* ===========================================
           RESPONSIVE - TABLETS AND MOBILE
           =========================================== */
        @media (max-width: 768px) {
            .container { padding: 12px 16px 24px; }
            
            .header-logo { max-width: 300px; }
            
            .input-section { padding: 16px; }
            
            .input-row { 
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-row input[type="text"] {
                min-width: 100%;
            }
            
            .btn {
                padding: 12px 16px;
                justify-content: center;
            }
            
            .tree-display-container {
                padding: 16px;
            }
            
            .node-label-container {
                min-width: 80px;
            }
            
            .node-actions button {
                padding: 4px;
                font-size: 11px;
            }
            
            .comparison-panels {
                flex-direction: column;
            }
            
            .results-stats {
                flex-direction: column;
                gap: 12px;
            }
            
            .pos-modal {
                padding: 14px;
            }
            
            .pos-row {
                flex-direction: column;
            }
            
            .pos-select {
                width: 100%;
            }

            .btn-separator {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .header-logo { max-width: 220px; }
            
            .btn {
                font-size: 13px;
                padding: 10px 12px;
            }
            
            .node-label-container {
                min-width: 60px;
                font-size: 10px;
            }
            
            .node-actions {
                gap: 2px;
            }
            
            .node-actions button {
                padding: 3px;
                font-size: 10px;
            }
            
            .results-summary {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // ===========================================
        // LABEL CATALOG (English terminology)
        // Based on standard introductory syntax textbooks
        // ===========================================
        const GTG_LABELS = {
            // SYNTACTIC FUNCTIONS (top label)
            clausesFunctions: {
                title: 'Clauses',
                items: [
                    { abbr: 'S', full: 'sentence' },
                    { abbr: 'CL', full: 'clause' },
                    { abbr: 'MC', full: 'main clause' },
                    { abbr: 'SC', full: 'subordinate clause' },
                    { abbr: 'RC', full: 'relative clause' },
                    { abbr: 'COMP CL', full: 'complement clause' },
                    { abbr: 'ADV CL', full: 'adverbial clause' },
                    { abbr: 'COORD', full: 'coordination' },
                ]
            },
            functions: {
                title: 'Grammatical functions',
                items: [
                    { abbr: 'SUBJ', full: 'subject' },
                    { abbr: 'DO', full: 'direct object' },
                    { abbr: 'IO', full: 'indirect object' },
                    { abbr: 'OBL', full: 'oblique' },
                    { abbr: 'PRED', full: 'predicate' },
                    { abbr: 'COMP', full: 'complement' },
                    { abbr: 'ADJUNCT', full: 'adjunct' },
                    { abbr: 'SPEC', full: 'specifier' },
                    { abbr: 'MOD', full: 'modifier' },
                    { abbr: 'APP', full: 'appositive' },
                    { abbr: 'VOC', full: 'vocative' },
                ]
            },
            internalFunctions: {
                title: 'Phrase-internal functions',
                items: [
                    { abbr: 'HEAD', full: 'head' },
                    { abbr: 'DET', full: 'determiner' },
                    { abbr: 'MOD', full: 'modifier' },
                    { abbr: 'COMP', full: 'complement' },
                    { abbr: 'CONJ', full: 'conjunction' },
                ]
            },
            // CATEGORIES / WORD CLASSES (bottom label)
            phrases: {
                title: 'Phrases',
                items: [
                    { abbr: 'NP', full: 'noun phrase' },
                    { abbr: 'VP', full: 'verb phrase' },
                    { abbr: 'PP', full: 'prepositional phrase' },
                    { abbr: 'AP', full: 'adjective phrase' },
                    { abbr: 'AdvP', full: 'adverb phrase' },
                    { abbr: 'DP', full: 'determiner phrase' },
                    { abbr: 'CP', full: 'complementizer phrase' },
                    { abbr: 'IP', full: 'inflection phrase' },
                ]
            },
            wordClasses: {
                title: 'Word classes',
                items: [
                    { abbr: 'N', full: 'noun' },
                    { abbr: 'V', full: 'verb' },
                    { abbr: 'Adj', full: 'adjective' },
                    { abbr: 'Adv', full: 'adverb' },
                    { abbr: 'P', full: 'preposition' },
                    { abbr: 'Det', full: 'determiner' },
                    { abbr: 'Pron', full: 'pronoun' },
                    { abbr: 'Conj', full: 'conjunction' },
                    { abbr: 'Comp', full: 'complementizer' },
                    { abbr: 'Aux', full: 'auxiliary' },
                    { abbr: 'Mod', full: 'modal' },
                    { abbr: 'Neg', full: 'negation' },
                    { abbr: 'Interj', full: 'interjection' },
                ]
            },
            determiners: {
                title: 'Determiner types',
                items: [
                    { abbr: 'Art', full: 'article' },
                    { abbr: 'Dem', full: 'demonstrative' },
                    { abbr: 'Poss', full: 'possessive' },
                    { abbr: 'Quant', full: 'quantifier' },
                    { abbr: 'Num', full: 'numeral' },
                    { abbr: 'Indef', full: 'indefinite' },
                    { abbr: 'Interr', full: 'interrogative' },
                    { abbr: 'Rel', full: 'relative' },
                ]
            },
            pronouns: {
                title: 'Pronoun types',
                items: [
                    { abbr: 'Pers', full: 'personal pronoun' },
                    { abbr: 'Refl', full: 'reflexive pronoun' },
                    { abbr: 'Dem', full: 'demonstrative pronoun' },
                    { abbr: 'Poss', full: 'possessive pronoun' },
                    { abbr: 'Indef', full: 'indefinite pronoun' },
                    { abbr: 'Interr', full: 'interrogative pronoun' },
                    { abbr: 'Rel', full: 'relative pronoun' },
                ]
            },
            clausesCat: {
                title: 'Clause types',
                items: [
                    { abbr: 'S', full: 'sentence' },
                    { abbr: 'CL', full: 'clause' },
                    { abbr: 'MC', full: 'main clause' },
                    { abbr: 'SC', full: 'subordinate clause' },
                    { abbr: 'RC', full: 'relative clause' },
                    { abbr: 'COORD', full: 'coordination' },
                ]
            }
        };

        // Sections for top label (functions)
        const FUNC_SECTIONS = ['clausesFunctions', 'functions', 'internalFunctions'];
        
        // Sections for bottom label (categories)
        const CAT_SECTIONS = ['phrases', 'wordClasses', 'determiners', 'pronouns', 'clausesCat'];

        const SyntaxTreeBuilder = () => {
            // ===========================================
            // STATE
            // ===========================================
            const [sentence, setSentence] = useState('');
            const [tree, setTree] = useState(null);
            const [divisionMode, setDivisionMode] = useState(null);
            const [selectedCuts, setSelectedCuts] = useState([]);
            const [posPicker, setPosPicker] = useState(null);

            // Exercise mode
            const [exerciseMode, setExerciseMode] = useState(false);
            const [modelTree, setModelTree] = useState(null);
            const [showComparison, setShowComparison] = useState(false);
            const [comparisonResults, setComparisonResults] = useState(null);

            // Undo/Redo history
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const isUndoRedo = useRef(false);

            // Instructions panel
            const [instructionsCollapsed, setInstructionsCollapsed] = useState(true);

            // Files modal
            const [showFilesModal, setShowFilesModal] = useState(false);
            const [filesActiveTab, setFilesActiveTab] = useState('local');
            const [driveUrl, setDriveUrl] = useState(() => localStorage.getItem('ent_drive_url') || '');
            const [driveStatus, setDriveStatus] = useState({ type: null, message: '' });
            const [driveFiles, setDriveFiles] = useState([]);
            const [selectedDriveFile, setSelectedDriveFile] = useState(null);
            const [collapsedFolders, setCollapsedFolders] = useState({});

            // References
            const fileInputRef = useRef(null);
            const exerciseInputRef = useRef(null);

            // ===========================================
            // UTILITIES
            // ===========================================
            const getFileName = (extension) => {
                const words = sentence.trim().split(/\s+/).slice(0, 5).join('_');
                // Use .ent as default extension for JSON
                const ext = extension === 'json' ? 'ent' : extension;
                return `${words}.${ext}`;
            };

            const normalizeSentence = (text) => {
                return text.trim()
                    // Normalize curly apostrophes to straight
                    .replace(/['']/g, "'")
                    // Irregular negative contractions (must come first)
                    .replace(/\bwon't\b/gi, 'will not')
                    .replace(/\bcan't\b/gi, 'cannot')
                    .replace(/\bshan't\b/gi, 'shall not')
                    .replace(/\bain't\b/gi, 'am not')
                    // Regular negative contractions: don't, doesn't, didn't, isn't, aren't, etc.
                    .replace(/n't\b/gi, ' not')
                    // Verb contractions with pronouns
                    .replace(/\b(I|you|we|they|he|she|it|who|what|that|there|here)'ll\b/gi, '$1 will')
                    .replace(/\b(I|you|we|they|he|she|it|who|what|that|there|here)'d\b/gi, '$1 would')
                    .replace(/\b(I|you|we|they|he|she|it|who|what|that|there|here)'ve\b/gi, '$1 have')
                    .replace(/\b(you|we|they|who|what|that|there|here)'re\b/gi, '$1 are')
                    .replace(/\b(he|she|it|who|what|that|there|here)'s\b/gi, '$1 is')
                    .replace(/\bI'm\b/gi, 'I am')
                    .replace(/\blet's\b/gi, 'let us');
            };

            const createEmptyTree = (text) => ({
                id: 'root',
                text: normalizeSentence(text),
                labelTop: '',
                labelBottom: '',
                children: null,
                isNucleus: false,
                isConsolidated: false
            });

            const makeNewNode = (text = '') => ({
                id: `added-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                text,
                labelTop: '',
                labelBottom: '',
                children: null,
                isNucleus: false,
                isInserted: true,
                isConsolidated: false
            });

            const updateNode = (node, id, updates) => {
                if (node.id === id) return { ...node, ...updates };
                if (node.children) {
                    return { ...node, children: node.children.map(c => updateNode(c, id, updates)) };
                }
                return node;
            };

            const findNodeById = (n, id) => {
                if (!n) return null;
                if (n.id === id) return n;
                if (n.children) {
                    for (const c of n.children) {
                        const r = findNodeById(c, id);
                        if (r) return r;
                    }
                }
                return null;
            };

            const shorten = (s, n = 18) => {
                const t = (s || '').trim();
                if (!t) return 'âˆ…';
                return t.length > n ? t.slice(0, n - 1) + 'â€¦' : t;
            };

            const buildPosLabel = (i, siblings) => {
                const n = siblings.length;
                if (i === 1) return 'At the beginning';
                if (i === n + 1) return 'At the end';
                const left = shorten(siblings[i - 2]);
                const right = shorten(siblings[i - 1]);
                return `Between "${left}" and "${right}"`;
            };

            // ===========================================
            // TEXT FORMATTING IN LABELS
            // ===========================================
            const formatLabelText = (text) => {
                if (!text) return null;
                
                const parts = [];
                let remaining = text;
                let key = 0;
                
                const patterns = [
                    { regex: /\*\*([^*]+)\*\*/, style: { fontWeight: 'bold' } },
                    { regex: /\*([^*]+)\*/, style: { fontStyle: 'italic' } },
                    { regex: /_([^_]+)_/, style: { fontSize: '0.75em', verticalAlign: 'sub' } },
                    { regex: /Â¨([^Â¨]+)Â¨/, style: { fontSize: '0.75em', verticalAlign: 'super' } }
                ];
                
                while (remaining.length > 0) {
                    let earliestMatch = null;
                    let earliestIndex = remaining.length;
                    let matchedPattern = null;
                    
                    for (const pattern of patterns) {
                        const match = remaining.match(pattern.regex);
                        if (match && match.index < earliestIndex) {
                            earliestMatch = match;
                            earliestIndex = match.index;
                            matchedPattern = pattern;
                        }
                    }
                    
                    if (earliestMatch && matchedPattern) {
                        if (earliestIndex > 0) {
                            parts.push(<span key={key++}>{remaining.substring(0, earliestIndex)}</span>);
                        }
                        parts.push(
                            <span key={key++} style={matchedPattern.style}>
                                {earliestMatch[1]}
                            </span>
                        );
                        remaining = remaining.substring(earliestIndex + earliestMatch[0].length);
                    } else {
                        parts.push(<span key={key++}>{remaining}</span>);
                        break;
                    }
                }
                
                return parts.length > 0 ? parts : text;
            };

            // Function to apply HTML formatting in export (DOM)
            const applyFormatToSpan = (span, text) => {
                if (!text) {
                    span.textContent = '';
                    return;
                }
                
                span.innerHTML = '';
                let remaining = text;
                
                const patterns = [
                    { regex: /\*\*([^*]+)\*\*/, tag: 'strong', style: '' },
                    { regex: /\*([^*]+)\*/, tag: 'em', style: '' },
                    { regex: /_([^_]+)_/, tag: 'sub', style: 'font-size: 0.75em;' },
                    { regex: /Â¨([^Â¨]+)Â¨/, tag: 'sup', style: 'font-size: 0.75em;' }
                ];
                
                while (remaining.length > 0) {
                    let earliestMatch = null;
                    let earliestIndex = remaining.length;
                    let matchedPattern = null;
                    
                    for (const pattern of patterns) {
                        const match = remaining.match(pattern.regex);
                        if (match && match.index < earliestIndex) {
                            earliestMatch = match;
                            earliestIndex = match.index;
                            matchedPattern = pattern;
                        }
                    }
                    
                    if (earliestMatch && matchedPattern) {
                        if (earliestIndex > 0) {
                            span.appendChild(document.createTextNode(remaining.substring(0, earliestIndex)));
                        }
                        const el = document.createElement(matchedPattern.tag);
                        if (matchedPattern.style) el.style.cssText = matchedPattern.style;
                        el.textContent = earliestMatch[1];
                        span.appendChild(el);
                        remaining = remaining.substring(earliestIndex + earliestMatch[0].length);
                    } else {
                        span.appendChild(document.createTextNode(remaining));
                        break;
                    }
                }
            };

            // ===========================================
            // UNDO/REDO HISTORY
            // ===========================================
            useEffect(() => {
                if (tree && !isUndoRedo.current) {
                    setHistory(prev => {
                        const newHistory = prev.slice(0, historyIndex + 1);
                        newHistory.push(JSON.stringify(tree));
                        if (newHistory.length > 50) newHistory.shift();
                        return newHistory;
                    });
                    setHistoryIndex(prev => Math.min(prev + 1, 49));
                }
                isUndoRedo.current = false;
            }, [tree]);

            const canUndo = historyIndex > 0;
            const canRedo = historyIndex < history.length - 1;

            const handleUndo = useCallback(() => {
                if (canUndo) {
                    isUndoRedo.current = true;
                    setHistoryIndex(prev => prev - 1);
                    setTree(JSON.parse(history[historyIndex - 1]));
                }
            }, [canUndo, history, historyIndex]);

            const handleRedo = useCallback(() => {
                if (canRedo) {
                    isUndoRedo.current = true;
                    setHistoryIndex(prev => prev + 1);
                    setTree(JSON.parse(history[historyIndex + 1]));
                }
            }, [canRedo, history, historyIndex]);

            // ===========================================
            // SAVE (defined here for keyboard shortcuts)
            // ===========================================
            const handleSaveJSON = useCallback(() => {
                if (!tree) return;
                const blob = new Blob([JSON.stringify({ sentence, tree }, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                const words = sentence.trim().split(/\s+/).slice(0, 5).join('_');
                a.download = `${words}.ent`;
                a.click();
            }, [tree, sentence]);

            // ===========================================
            // GOOGLE DRIVE API
            // ===========================================
            const GOOGLE_API_KEY = 'AIzaSyB1XWEgGpX-SWi6GlzqXcOOk7pFc6jLCsU';

            const extractFolderId = (url) => {
                // Soportar varios formatos de URL de Google Drive
                const patterns = [
                    /\/folders\/([a-zA-Z0-9_-]+)/,
                    /id=([a-zA-Z0-9_-]+)/,
                    /^([a-zA-Z0-9_-]+)$/
                ];
                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match) return match[1];
                }
                return null;
            };

            const fetchDriveFolder = async (folderId, folderName = 'Root') => {
                const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&key=${GOOGLE_API_KEY}&fields=files(id,name,mimeType)&orderBy=name`;
                const response = await fetch(url);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'Error accessing folder');
                }
                const data = await response.json();
                return { folderId, folderName, files: data.files || [] };
            };

            const organizeFiles = async (rootFolderId) => {
                const result = [];
                const rootData = await fetchDriveFolder(rootFolderId, 'Root');
                
                // Separate .ent files and subfolders
                const entFiles = rootData.files.filter(f => f.name.endsWith('.ent'));
                const folders = rootData.files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
                
                // Add root files
                if (entFiles.length > 0) {
                    result.push({ folderName: null, files: entFiles });
                }
                
                // Process subfolders
                for (const folder of folders) {
                    try {
                        const folderData = await fetchDriveFolder(folder.id, folder.name);
                        const folderEntFiles = folderData.files.filter(f => f.name.endsWith('.ent'));
                        if (folderEntFiles.length > 0) {
                            result.push({ folderName: folder.name, folderId: folder.id, files: folderEntFiles });
                        }
                    } catch (e) {
                        console.warn(`Could not access folder ${folder.name}:`, e);
                    }
                }
                
                return result;
            };

            const handleConnectDrive = async () => {
                const folderId = extractFolderId(driveUrl.trim());
                if (!folderId) {
                    setDriveStatus({ type: 'error', message: 'Invalid URL. Please enter a Google Drive folder URL.' });
                    return;
                }

                // Save URL to localStorage
                localStorage.setItem('ent_drive_url', driveUrl.trim());
                
                setDriveStatus({ type: 'loading', message: 'Connecting to Google Drive...' });
                setDriveFiles([]);
                setSelectedDriveFile(null);

                try {
                    const files = await organizeFiles(folderId);
                    if (files.length === 0 || files.every(f => f.files.length === 0)) {
                        setDriveStatus({ type: 'error', message: 'No .ent files found in this folder.' });
                        return;
                    }
                    setDriveFiles(files);
                    setDriveStatus({ type: 'success', message: `Found ${files.reduce((sum, f) => sum + f.files.length, 0)} .ent files` });
                } catch (error) {
                    console.error('Error connecting to Google Drive:', error);
                    if (error.message.includes('API key')) {
                        setDriveStatus({ type: 'error', message: 'API Key error. Check configuration.' });
                    } else if (error.message.includes('not found') || error.message.includes('404')) {
                        setDriveStatus({ type: 'error', message: 'Folder not found. Check the URL.' });
                    } else if (error.message.includes('permission') || error.message.includes('403')) {
                        setDriveStatus({ type: 'error', message: 'No permissions. The folder must be public (shared with "Anyone with the link").' });
                    } else {
                        setDriveStatus({ type: 'error', message: `Error: ${error.message}` });
                    }
                }
            };

            const fetchDriveFile = async (fileId) => {
                const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&key=${GOOGLE_API_KEY}`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Could not download file');
                }
                return await response.json();
            };

            const handleLoadFromDrive = async (asExercise = false) => {
                if (!selectedDriveFile) return;

                setDriveStatus({ type: 'loading', message: 'Loading file...' });

                try {
                    const data = await fetchDriveFile(selectedDriveFile.id);
                    
                    if (!data.tree || !data.sentence) {
                        setDriveStatus({ type: 'error', message: 'File does not have the expected format.' });
                        return;
                    }

                    if (asExercise) {
                        // Load as exercise
                        const originalSentence = data.sentence || '';
                        setSentence(originalSentence);
                        setModelTree(data.tree);
                        const newTree = createEmptyTree(originalSentence);
                        setTree(newTree);
                        setDivisionMode(null);
                        setSelectedCuts([]);
                        setExerciseMode(true);
                        setShowComparison(false);
                        setComparisonResults(null);
                        setHistory([JSON.stringify(newTree)]);
                        setHistoryIndex(0);
                    } else {
                        // Load as reference (view/edit)
                        setSentence(data.sentence || '');
                        setTree(data.tree);
                        setExerciseMode(false);
                        setModelTree(null);
                        setShowComparison(false);
                        setHistory([JSON.stringify(data.tree)]);
                        setHistoryIndex(0);
                    }

                    setShowFilesModal(false);
                    setSelectedDriveFile(null);
                } catch (error) {
                    console.error('Error loading file:', error);
                    setDriveStatus({ type: 'error', message: `Error loading: ${error.message}` });
                }
            };

            const toggleFolder = (folderId) => {
                setCollapsedFolders(prev => ({
                    ...prev,
                    [folderId]: !prev[folderId]
                }));
            };

            // ===========================================
            // KEYBOARD SHORTCUTS
            // ===========================================
            useEffect(() => {
                const handleKeyDown = (e) => {
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const modifier = isMac ? e.metaKey : e.ctrlKey;
                    const key = e.key.toLowerCase();
                    
                    if (modifier && key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        handleUndo();
                    } else if (modifier && key === 'z' && e.shiftKey) {
                        e.preventDefault();
                        handleRedo();
                    } else if (modifier && key === 'y') {
                        e.preventDefault();
                        handleRedo();
                    } else if (modifier && key === 's') {
                        e.preventDefault();
                        handleSaveJSON();
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, handleSaveJSON]);

            // ===========================================
            // MAIN ACTIONS
            // ===========================================
            const startAnalysis = () => {
                if (sentence.trim()) {
                    const newTree = createEmptyTree(sentence);
                    setTree(newTree);
                    setDivisionMode(null);
                    setSelectedCuts([]);
                    setExerciseMode(false);
                    setModelTree(null);
                    setShowComparison(false);
                    // Reset history
                    setHistory([JSON.stringify(newTree)]);
                    setHistoryIndex(0);
                }
            };

            const handleDivide = () => {
                const node = findNodeById(tree, divisionMode);
                const words = node.text.split(/\s+/);
                const segments = [];
                let start = 0;
                
                // Ensure cuts are sorted numerically
                const sortedCuts = [...selectedCuts].sort((a, b) => a - b);
                
                [...sortedCuts, words.length - 1].forEach(cut => {
                    segments.push(words.slice(start, cut + 1).join(' '));
                    start = cut + 1;
                });
                
                const children = segments.filter(s => s.trim()).map((s, i) => ({
                    id: `${divisionMode}-${i}-${Date.now()}`,
                    text: s,
                    labelTop: '',
                    labelBottom: '',
                    children: null,
                    isNucleus: false,
                    isConsolidated: false
                }));
                
                setTree(prev => updateNode(prev, divisionMode, { children }));
                setDivisionMode(null);
                setSelectedCuts([]);
            };

            const toggleConsolidated = (nodeId) => {
                setTree(prev => {
                    const node = findNodeById(prev, nodeId);
                    return updateNode(prev, nodeId, { isConsolidated: !node.isConsolidated });
                });
            };

            const expandNode = (nodeId) => {
                setTree(prev => {
                    const node = findNodeById(prev, nodeId);
                    if (!node || node.children) return prev;
                    
                    // Create a child with the same text as the parent node
                    const childNode = {
                        id: `${nodeId}-child-${Date.now()}`,
                        text: node.text,
                        labelTop: '',
                        labelBottom: '',
                        children: null,
                        isNucleus: node.isNucleus,
                        isConsolidated: false
                    };
                    
                    return updateNode(prev, nodeId, { 
                        children: [childNode],
                        isNucleus: false
                    });
                });
            };

            const addChildNode = (parentId) => {
                const txt = window.prompt('Text for extra node:');
                if (txt === null) return;

                const parent = findNodeById(tree, parentId);
                const existing = parent?.children ? [...parent.children] : [];
                const siblings = existing.map(c => (c.text || '').trim() || 'âˆ…');

                setPosPicker({
                    parentId,
                    txt: txt.trim(),
                    siblings,
                    pos: 1
                });
            };

            const confirmInsertAtPosition = () => {
                if (!posPicker) return;
                const { parentId, txt, pos } = posPicker;

                setTree(prev => {
                    const parent = findNodeById(prev, parentId);
                    const existing = parent?.children ? [...parent.children] : [];
                    const n = existing.length;
                    let p = parseInt(pos, 10);
                    if (Number.isNaN(p)) p = n + 1;
                    p = Math.max(1, Math.min(n + 1, p));

                    const newNode = makeNewNode(txt);
                    existing.splice(p - 1, 0, newNode);
                    return updateNode(prev, parentId, { children: existing });
                });

                setPosPicker(null);
            };

            // ===========================================
            // LOAD FILES
            // ===========================================
            const handleLoadJSON = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!imported.tree || !imported.sentence) {
                            alert('Error: File does not have the expected format.\n\nThe file must contain "sentence" and "tree" properties.');
                            return;
                        }
                        setSentence(imported.sentence || '');
                        setTree(imported.tree);
                        setExerciseMode(false);
                        setModelTree(null);
                        setShowComparison(false);
                        // Reset history with loaded tree
                        setHistory([JSON.stringify(imported.tree)]);
                        setHistoryIndex(0);
                    } catch (error) {
                        alert('Error reading file.\n\nThe file is not valid (.ent or .json) or is corrupted.\n\nDetail: ' + error.message);
                    }
                };
                reader.onerror = () => {
                    alert('Error reading file. Please try again.');
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            const handleLoadExercise = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!imported.tree || !imported.sentence) {
                            alert('Error: File does not have the expected format.\n\nThe exercise file must contain "sentence" and "tree" properties.');
                            return;
                        }
                        const originalSentence = imported.sentence || '';
                        setSentence(originalSentence);
                        setModelTree(imported.tree);
                        const newTree = createEmptyTree(originalSentence);
                        setTree(newTree);
                        setDivisionMode(null);
                        setSelectedCuts([]);
                        setExerciseMode(true);
                        setShowComparison(false);
                        setComparisonResults(null);
                        // Reset history
                        setHistory([JSON.stringify(newTree)]);
                        setHistoryIndex(0);
                    } catch (error) {
                        alert('Error reading exercise file.\n\nThe file is not valid or is corrupted.\n\nDetail: ' + error.message);
                    }
                };
                reader.onerror = () => {
                    alert('Error reading file. Please try again.');
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            // ===========================================
            // EXERCISE MODE
            // ===========================================
            const compareTrees = (studentTree, modelTree) => {
                const results = {
                    totalNodes: 0,
                    correctNodes: 0,
                    totalLabelTopParts: 0,
                    totalLabelBottomParts: 0,
                    correctLabelTopParts: 0,
                    correctLabelBottomParts: 0,
                    totalElements: 0,
                    correctElements: 0,
                    errorElements: 0,
                    accuracy: 0,
                    nodeComparisons: new Map()
                };

                const normalizeText = (text) => (text || '').trim().toLowerCase();
                
                // Extract normalized parts from a label
                const getLabelParts = (label) => {
                    if (!label) return [];
                    return label.split('/')
                        .map(p => p.trim().toLowerCase().replace(/\s+/g, ''))
                        .filter(p => p);
                };
                
                // Normalize complete label (for full equality comparison)
                const normalizeLabel = (label) => {
                    const parts = getLabelParts(label);
                    return parts.sort().join('â€¢');
                };
                
                // Compare two labels and return how many model parts matched
                const compareLabelParts = (studentLabel, modelLabel) => {
                    const studentParts = getLabelParts(studentLabel);
                    const modelParts = getLabelParts(modelLabel);
                    
                    if (modelParts.length === 0) {
                        return { total: 0, correct: 0, allMatch: true };
                    }
                    
                    const studentSet = new Set(studentParts);
                    let correct = 0;
                    for (const part of modelParts) {
                        if (studentSet.has(part)) correct++;
                    }
                    
                    // allMatch is true if all parts match (same content, regardless of order)
                    const allMatch = correct === modelParts.length && studentParts.length === modelParts.length;
                    
                    return { total: modelParts.length, correct, allMatch };
                };
                
                const getChildCount = (node) => (node?.children?.length) || 0;

                // Check if student children match model children
                // For normal nodes: check exact text at same position
                // For extra nodes (isInserted): only check label match (ignore text and position)
                const childrenMatch = (studentNode, modelNode) => {
                    const studentChildren = studentNode?.children || [];
                    const modelChildren = modelNode?.children || [];
                    
                    // Separate normal and extra nodes
                    const studentNormal = studentChildren.filter(c => !c.isInserted);
                    const studentExtra = studentChildren.filter(c => c.isInserted);
                    const modelNormal = modelChildren.filter(c => !c.isInserted);
                    const modelExtra = modelChildren.filter(c => c.isInserted);
                    
                    // Check that number of normal nodes matches
                    if (studentNormal.length !== modelNormal.length) return false;
                    
                    // Check that number of extra nodes matches
                    if (studentExtra.length !== modelExtra.length) return false;
                    
                    // Check that each normal node has same text at same position
                    for (let i = 0; i < modelNormal.length; i++) {
                        if (normalizeText(studentNormal[i]?.text) !== normalizeText(modelNormal[i]?.text)) {
                            return false;
                        }
                    }
                    
                    // For extra nodes: check that each student extra node 
                    // has labels matching some model extra node
                    const usedModelExtras = new Set();
                    for (const studentExtraNode of studentExtra) {
                        const studentLabelTop = normalizeLabel(studentExtraNode.labelTop);
                        const studentLabelBottom = normalizeLabel(studentExtraNode.labelBottom);
                        
                        // Find model extra node with same labels not yet used
                        let foundMatch = false;
                        for (let j = 0; j < modelExtra.length; j++) {
                            if (usedModelExtras.has(j)) continue;
                            
                            const modelLabelTop = normalizeLabel(modelExtra[j].labelTop);
                            const modelLabelBottom = normalizeLabel(modelExtra[j].labelBottom);
                            
                            if (studentLabelTop === modelLabelTop && studentLabelBottom === modelLabelBottom) {
                                usedModelExtras.add(j);
                                foundMatch = true;
                                break;
                            }
                        }
                        
                        if (!foundMatch) return false;
                    }
                    
                    return true;
                };

                // Count all model elements (for total score)
                const countModelElements = (modelNode) => {
                    const children = modelNode.children || [];
                    children.forEach((child) => {
                        results.totalNodes++;
                        const topParts = getLabelParts(child.labelTop);
                        const bottomParts = getLabelParts(child.labelBottom);
                        results.totalLabelTopParts += topParts.length;
                        results.totalLabelBottomParts += bottomParts.length;
                        countModelElements(child);
                    });
                };

                const compareNodes = (student, model, path = 'root') => {
                    if (!model) return;
                    
                    // 1. IDEAL SCORE: Always add based exclusively on model
                    results.totalNodes++;
                    const modelTopParts = getLabelParts(model.labelTop);
                    const modelBottomParts = getLabelParts(model.labelBottom);
                    results.totalLabelTopParts += modelTopParts.length;
                    results.totalLabelBottomParts += modelBottomParts.length;

                    // 2. Check if student has this node and if correctly identified
                    const hasStudent = !!student;
                    const isExtraNode = model.isInserted;
                    
                    // For normal nodes: check text match
                    // For extra nodes (isInserted): check label match (ignore text)
                    let nodeIdentifiedCorrectly;
                    if (isExtraNode) {
                        // Extra node: correctly identified if labels match
                        nodeIdentifiedCorrectly = hasStudent && 
                            normalizeLabel(student.labelTop) === normalizeLabel(model.labelTop) &&
                            normalizeLabel(student.labelBottom) === normalizeLabel(model.labelBottom);
                    } else {
                        // Normal node: correctly identified if text matches
                        nodeIdentifiedCorrectly = hasStudent && normalizeText(student.text) === normalizeText(model.text);
                    }
                    
                    // 3. Check if division is correct (children match exactly)
                    const divisionCorrect = nodeIdentifiedCorrectly && childrenMatch(student, model);
                    
                    // 4. Compare labels by parts
                    const topComparison = hasStudent 
                        ? compareLabelParts(student.labelTop, model.labelTop)
                        : { total: modelTopParts.length, correct: 0, allMatch: modelTopParts.length === 0 };
                    const bottomComparison = hasStudent 
                        ? compareLabelParts(student.labelBottom, model.labelBottom)
                        : { total: modelBottomParts.length, correct: 0, allMatch: modelBottomParts.length === 0 };

                    const comparison = {
                        path,
                        // Node is correctly identified
                        nodeCorrect: nodeIdentifiedCorrectly,
                        // Division is correct (children match)
                        divisionCorrect,
                        // Complete label comparison (all parts match)
                        labelTopMatch: topComparison.allMatch,
                        labelBottomMatch: bottomComparison.allMatch,
                        // Detailed part information for visualization
                        labelTopComparison: topComparison,
                        labelBottomComparison: bottomComparison,
                        studentNode: hasStudent ? student : null,
                        modelNode: model,
                        isExtraNode,
                        // Flag indicating if we should show error message and truncate
                        // (node correctly identified but incorrectly divided)
                        shouldTruncate: nodeIdentifiedCorrectly && !divisionCorrect && (getChildCount(model) > 0 || getChildCount(student) > 0)
                    };

                    // 5. CORRECT ANSWERS
                    // Node counts as correct if correctly identified
                    if (nodeIdentifiedCorrectly) {
                        results.correctNodes++;
                    }
                    // Labels are evaluated by parts
                    // For extra nodes, labels already counted as part of nodeIdentifiedCorrectly
                    if (!isExtraNode && hasStudent) {
                        results.correctLabelTopParts += topComparison.correct;
                        results.correctLabelBottomParts += bottomComparison.correct;
                    }

                    results.nodeComparisons.set(path, comparison);

                    // 6. RECURSION: Only continue if division is correct
                    if (divisionCorrect) {
                        const modelChildren = model.children || [];
                        const studentChildren = student?.children || [];
                        
                        // Separate normal and extra nodes
                        const modelNormal = modelChildren.filter(c => !c.isInserted);
                        const modelExtra = modelChildren.filter(c => c.isInserted);
                        const studentNormal = studentChildren.filter(c => !c.isInserted);
                        const studentExtra = studentChildren.filter(c => c.isInserted);
                        
                        // Match normal nodes by position
                        modelNormal.forEach((modelChild, mi) => {
                            const studentChild = studentNormal[mi] || null;
                            compareNodes(studentChild, modelChild, `${path}-n${mi}`);
                        });
                        
                        // Match extra nodes by labels
                        const usedStudentExtras = new Set();
                        modelExtra.forEach((modelChild, mi) => {
                            const modelLabelTop = normalizeLabel(modelChild.labelTop);
                            const modelLabelBottom = normalizeLabel(modelChild.labelBottom);
                            
                            // Find student extra node with same labels
                            let matchedStudent = null;
                            for (let si = 0; si < studentExtra.length; si++) {
                                if (usedStudentExtras.has(si)) continue;
                                
                                const studentLabelTop = normalizeLabel(studentExtra[si].labelTop);
                                const studentLabelBottom = normalizeLabel(studentExtra[si].labelBottom);
                                
                                if (studentLabelTop === modelLabelTop && studentLabelBottom === modelLabelBottom) {
                                    usedStudentExtras.add(si);
                                    matchedStudent = studentExtra[si];
                                    break;
                                }
                            }
                            
                            compareNodes(matchedStudent, modelChild, `${path}-e${mi}`);
                        });
                    } else {
                        // If division error (or node not identified), count remaining elements 
                        // from model for total score, but do NOT add correct
                        countModelElements(model);
                    }
                };

                compareNodes(studentTree, modelTree, 'root');

                results.totalElements = results.totalNodes + results.totalLabelTopParts + results.totalLabelBottomParts;
                results.correctElements = results.correctNodes + results.correctLabelTopParts + results.correctLabelBottomParts;
                results.errorElements = results.totalElements - results.correctElements;
                results.accuracy = results.totalElements ? (results.correctElements / results.totalElements) : 1;

                return results;
            };

            const handleFinishExercise = () => {
                if (!tree || !modelTree) return;
                const results = compareTrees(tree, modelTree);
                setComparisonResults(results);
                setShowComparison(true);
            };

            const resetExercise = () => {
                setExerciseMode(false);
                setModelTree(null);
                setShowComparison(false);
                setComparisonResults(null);
                setTree(null);
                setSentence('');
                // Reset history
                setHistory([]);
                setHistoryIndex(-1);
            };

            const newExercise = () => {
                setExerciseMode(true);
                setModelTree(null);
                setShowComparison(false);
                setComparisonResults(null);
                setTree(null);
                setSentence('');
                setDivisionMode(null);
                setSelectedCuts([]);
                // Reset history
                setHistory([]);
                setHistoryIndex(-1);
            };

            // ===========================================
            // EXPORT
            // ===========================================
            const handleExport = async (isTechnical = false) => {
                const treeWrapper = document.querySelector('.tree-wrapper');
                if (!treeWrapper) return;

                const treeContainer = document.querySelector('.tree-container');
                const originalOverflow = treeContainer.style.overflow;
                const originalWidth = treeContainer.style.width;
                const originalMaxWidth = treeContainer.style.maxWidth;
                treeContainer.style.overflow = 'visible';
                treeContainer.style.width = 'fit-content';
                treeContainer.style.maxWidth = 'none';

                if (isTechnical) treeWrapper.classList.add('technical-mode');

                // Hide edit buttons
                const undoBtns = treeWrapper.querySelectorAll('.btn-danger-soft');
                const clearBtns = treeWrapper.querySelectorAll('.clear-text-btn');
                const addBtns = treeWrapper.querySelectorAll('.add-node-btn');
                const splitBtns = treeWrapper.querySelectorAll('.split-toggle-btn');

                undoBtns.forEach(b => b.style.visibility = 'hidden');
                clearBtns.forEach(b => b.style.display = 'none');
                addBtns.forEach(b => b.style.display = 'none');
                splitBtns.forEach(b => b.style.display = 'none');

                let svg = null;
                const connectors = treeWrapper.querySelectorAll('.connector-v, .v-line-stem');
                const nodeBoxes = treeWrapper.querySelectorAll('.node-box');
                const inputData = [];

                const originalInlineStyles = {
                    connectors: Array.from(connectors).map(el => ({ el, cssText: el.style.cssText })),
                    nodeBoxes: Array.from(nodeBoxes).map(el => ({ el, cssText: el.style.cssText })),
                    treeWrapperPos: treeWrapper.style.position
                };

                // Helper function to get label value (from input or display)
                const getLabelValue = (element) => {
                    if (!element) return '';
                    if (element.tagName === 'INPUT') {
                        return element.value.trim();
                    } else {
                        // For label-display, use data-raw-value if exists to preserve format markers
                        const rawValue = element.getAttribute('data-raw-value');
                        if (rawValue !== null) {
                            return rawValue.trim();
                        }
                        return element.textContent.trim();
                    }
                };

                const nodeContainers = treeWrapper.querySelectorAll('.node-container');
                
                nodeContainers.forEach(container => {
                    // Search both inputs and displays (including those inside label-with-dropdown)
                    const topElements = container.querySelectorAll(':scope > .label-wrap > .label-input.label-top, :scope > .label-wrap > .label-display.label-top, :scope > .label-wrap > .label-with-dropdown > .label-input.label-top, :scope > .label-wrap > .label-with-dropdown > .label-display.label-top');
                    const bottomElements = container.querySelectorAll(':scope > .label-wrap > .label-input:not(.label-top), :scope > .label-wrap > .label-display:not(.label-top), :scope > .label-wrap > .label-with-dropdown > .label-input:not(.label-top), :scope > .label-wrap > .label-with-dropdown > .label-display:not(.label-top)');
                    
                    // The node-box is inside a flex div that is direct child of container
                    // IMPORTANT: Only search direct children, NOT descendants
                    let nodeBox = null;
                    const directChildren = container.children;
                    for (let child of directChildren) {
                        // If div that does NOT have children-container and is NOT connector-v
                        if (child.tagName === 'DIV' && 
                            !child.classList.contains('connector-v') && 
                            !child.classList.contains('label-wrap') &&
                            !child.querySelector(':scope > .children-container')) {
                            // Search node-box as direct child of this div
                            const box = child.querySelector(':scope > .node-box');
                            if (box) {
                                nodeBox = box;
                                break;
                            }
                        }
                    }
                    
                    const hasChildren = container.querySelector(':scope > div > .children-container') !== null;
                    const isNucleus = container.classList.contains('nucleus-node');
                    const isRootNode = container.parentElement && container.parentElement.classList.contains('tree-wrapper');

                    const topVal = Array.from(topElements).map(el => getLabelValue(el)).filter(v => v && v !== 'func.' && v !== 'cat.').join(' â€¢ ');
                    const botVal = Array.from(bottomElements).map(el => getLabelValue(el)).filter(v => v && v !== 'func.' && v !== 'cat.').join(' â€¢ ');

                    const slashSeparators = container.querySelectorAll(':scope > .label-wrap > .slash-separator');
                    slashSeparators.forEach(s => s.style.display = 'none');
                    
                    // Hide complete label-wraps
                    const labelWraps = container.querySelectorAll(':scope > .label-wrap');

                    if (isTechnical && hasChildren) {
                        // In technical mode with children, we do NOT extract or show node text
                        // to avoid redundancy and misalignment in tree diagram.
                        if (nodeBox) nodeBox.style.display = 'none';
                        
                        let combinedText = '';
                        if (topVal && botVal) combinedText = `${topVal} â€¢ ${botVal}`;
                        else if (topVal) combinedText = `${topVal}`;
                        else if (botVal) combinedText = `${botVal}`;
                        
                        const mergedSpan = document.createElement('span');
                        mergedSpan.className = 'exp-merged';
                        mergedSpan.style.cssText = `display: block; text-align: center; font-size: 16px; color: #111827; font-weight: ${isNucleus ? 'bold' : 'normal'}; padding: 4px; text-transform: uppercase;`;
                        applyFormatToSpan(mergedSpan, combinedText.toUpperCase());
                        
                        labelWraps.forEach(lw => lw.style.display = 'none');

                        inputData.push({ type: 'merged', labelWraps, box: nodeBox, span: mergedSpan, textSpan: null, parent: container, slashSeparators });
                        
                        // Insert mergedSpan at beginning of container
                        container.insertBefore(mergedSpan, container.firstChild);
                    } else {
                        const processLabels = (elements, isTop, combinedVal, labelWrap) => {
                            const span = document.createElement('span');
                            
                            if (!combinedVal) {
                                span.style.display = 'none';
                                const allConnectors = container.querySelectorAll(':scope > .connector-v');

                                if (isTop) {
                                    if (allConnectors.length >= 1) {
                                        if (!isTechnical && isRootNode) {
                                            allConnectors[0].style.display = 'none';
                                            inputData.push({ type: 'connector-hidden', connector: allConnectors[0] });
                                        } else {
                                            const currentHeight = parseInt(window.getComputedStyle(allConnectors[0]).height) || 12;
                                            const extraHeight = 23;
                                            allConnectors[0].dataset.originalHeight = currentHeight;
                                            allConnectors[0].style.height = (currentHeight + extraHeight) + 'px';
                                            inputData.push({ type: 'connector-extended', connector: allConnectors[0] });
                                        }
                                    }
                                } else {
                                    if (allConnectors.length >= 2) {
                                        allConnectors[1].style.display = 'none';
                                        inputData.push({ type: 'connector-hidden', connector: allConnectors[1] });
                                    }
                                }
                            } else {
                                let val = combinedVal;
                                if (isTechnical) val = `[${val}]`;
                                
                                span.className = isTop ? 'exp-top' : 'exp-bottom';
                                const textColor = isTechnical ? '#6b7280' : '#334155';
                                const transform = isTop ? 'uppercase' : 'none';
                                let marginStyle = isTechnical ? (isTop ? 'margin-bottom: 2px;' : 'margin-top: 2px;') : '';
                                const borderStyle = isTechnical ? 'none' : '1px solid #cbd5e1';
                                const bgStyle = isTechnical ? 'transparent' : '#f1f5f9';

                                span.style.cssText = `${marginStyle} display: inline-block; min-width: 95px; text-align: center; font-size: 11px; font-family: Arial, sans-serif; padding: 4px; border: ${borderStyle}; border-radius: 4px; background-color: ${bgStyle}; color: ${textColor}; font-weight: ${container.classList.contains('nucleus-node') ? 'bold' : 'normal'}; text-transform: ${transform};`;
                                applyFormatToSpan(span, isTop ? val.toUpperCase() : val);
                            }
                            
                            if (labelWrap) {
                                labelWrap.style.display = 'none';
                            }

                            inputData.push({ type: 'single', labelWrap, span, parent: container, isTop });
                            
                            if (isTop) {
                                container.insertBefore(span, container.firstChild);
                            } else {
                                const childrenDiv = container.querySelector(':scope > div:last-child');
                                if (childrenDiv && childrenDiv.querySelector('.children-container')) {
                                    container.insertBefore(span, childrenDiv);
                                } else {
                                    container.appendChild(span);
                                }
                            }
                        };
                        
                        // Find label-wraps for top and bottom
                        const topLabelWrap = Array.from(labelWraps).find(lw => lw.querySelector('.label-top'));
                        const bottomLabelWrap = Array.from(labelWraps).find(lw => lw.querySelector(':not(.label-top)') && !lw.querySelector('.label-top'));
                        
                        processLabels(Array.from(topElements), true, topVal, topLabelWrap);
                        processLabels(Array.from(bottomElements), false, botVal, bottomLabelWrap || (labelWraps[1] || null));
                    }
                });

                if (isTechnical) {
                    connectors.forEach(c => c.style.display = 'none');
                    nodeBoxes.forEach(b => { 
                        if (b && b.style.display !== 'none') { 
                            b.style.border = 'none'; 
                            b.style.backgroundColor = 'transparent'; 
                        }
                    });
                    
                    const rect = treeWrapper.getBoundingClientRect();
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', rect.width);
                    svg.setAttribute('height', rect.height);
                    svg.style.cssText = `position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;`;
                    treeWrapper.style.position = 'relative';
                    treeWrapper.appendChild(svg);
                    
                    const getPos = (el) => {
                        const r = el.getBoundingClientRect();
                        return { x: r.left + r.width / 2 - rect.left, top: r.top - rect.top, bottom: r.bottom - rect.top };
                    };
                    
                    // Helper function to find direct node-box of a container
                    const findDirectNodeBox = (container) => {
                        const directChildren = container.children;
                        for (let child of directChildren) {
                            // If div that does NOT have children-container, connector-v or label-wrap
                            if (child.tagName === 'DIV' && 
                                !child.classList.contains('connector-v') && 
                                !child.classList.contains('label-wrap') &&
                                !child.querySelector(':scope > .children-container')) {
                                const box = child.querySelector(':scope > .node-box');
                                if (box) return box;
                            }
                        }
                        return null;
                    };
                    
                    const getTopConnectionPoint = (container) => {
                        const merged = container.querySelector(':scope > .exp-merged');
                        if (merged) return merged;
                        const expTop = container.querySelector(':scope > .exp-top');
                        if (expTop && expTop.style.display !== 'none') return expTop;
                        const nodeBox = findDirectNodeBox(container);
                        if (nodeBox && nodeBox.style.display !== 'none') return nodeBox;
                        const expBottom = container.querySelector(':scope > .exp-bottom');
                        if (expBottom && expBottom.style.display !== 'none') return expBottom;
                        return null;
                    };
                    
                    treeWrapper.querySelectorAll('.node-container').forEach(cont => {
                        const pLabel = cont.querySelector(':scope > .exp-merged');
                        const textNode = cont.querySelector(':scope > .exp-text-node');
                        const nodeBox = findDirectNodeBox(cont);
                        const branches = cont.querySelector(':scope > div > .children-container');
                        
                        if (pLabel && branches) {
                            // Use exp-merged (since nodeBox and textSpan are hidden/null in technical mode for parents)
                            let connectionSource = pLabel;
                            if (textNode && textNode.textContent.trim()) {
                                connectionSource = textNode;
                            }
                            const pPos = getPos(connectionSource);
                            Array.from(branches.children).forEach(branch => {
                                const childContainer = branch.querySelector(':scope > .node-container');
                                if (childContainer) {
                                    const cTarget = getTopConnectionPoint(childContainer);
                                    if (cTarget) {
                                        const cPos = getPos(cTarget);
                                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                        line.setAttribute('x1', pPos.x);
                                        line.setAttribute('y1', pPos.bottom);
                                        line.setAttribute('x2', cPos.x);
                                        line.setAttribute('y2', cPos.top);
                                        line.setAttribute('stroke', 'black');
                                        line.setAttribute('stroke-width', '1.5');
                                        svg.appendChild(line);
                                    }
                                }
                            });
                        }
                    });
                }

                const canvas = await html2canvas(treeWrapper, { 
                    backgroundColor: null, 
                    scale: 2,
                    width: treeWrapper.scrollWidth,
                    height: treeWrapper.scrollHeight
                });
                
                const link = document.createElement('a');
                link.download = getFileName('png');
                link.href = canvas.toDataURL();
                link.click();

                // Restore styles
                treeContainer.style.overflow = originalOverflow;
                treeContainer.style.width = originalWidth;
                treeContainer.style.maxWidth = originalMaxWidth;

                if (isTechnical) treeWrapper.classList.remove('technical-mode');
                if (svg) svg.remove();
                treeWrapper.style.position = originalInlineStyles.treeWrapperPos;
                
                inputData.forEach(d => {
                    if (d.type === 'connector-hidden') {
                        d.connector.style.display = '';
                    } else if (d.type === 'connector-extended') {
                        const originalHeight = d.connector.dataset.originalHeight || '12';
                        d.connector.style.height = originalHeight + 'px';
                        delete d.connector.dataset.originalHeight;
                    } else if (d.type === 'merged') {
                        d.span.remove();
                        if (d.textSpan) d.textSpan.remove();
                        d.labelWraps.forEach(lw => lw.style.display = '');
                        if (d.box) d.box.style.display = '';
                        d.slashSeparators.forEach(s => s.style.display = '');
                    } else {
                        d.span.remove();
                        if (d.labelWrap) {
                            d.labelWrap.style.display = '';
                        }
                    }
                });
                
                originalInlineStyles.connectors.forEach(({ el, cssText }) => { el.style.cssText = cssText; });
                originalInlineStyles.nodeBoxes.forEach(({ el, cssText }) => { el.style.cssText = cssText; });

                undoBtns.forEach(b => b.style.visibility = 'visible');
                clearBtns.forEach(b => b.style.display = '');
                addBtns.forEach(b => b.style.display = '');
                splitBtns.forEach(b => b.style.display = '');
            };

            // ===========================================
            // LABEL RENDERING WITH DROPDOWN
            // ===========================================
            const [editingLabel, setEditingLabel] = useState(null);
            const [dropdownOpen, setDropdownOpen] = useState(null);
            const [dropdownSearch, setDropdownSearch] = useState('');

            // Dropdown component to select labels
            const LabelDropdown = ({ isTop, onSelect, onClose }) => {
                const sections = isTop ? FUNC_SECTIONS : CAT_SECTIONS;
                const searchLower = dropdownSearch.toLowerCase();
                
                const filteredSections = sections.map(sectionKey => {
                    const section = GTG_LABELS[sectionKey];
                    const filtered = section.items.filter(item => 
                        item.abbr.toLowerCase().includes(searchLower) ||
                        item.full.toLowerCase().includes(searchLower)
                    );
                    return { ...section, items: filtered, key: sectionKey };
                }).filter(s => s.items.length > 0);

                return (
                    <div className="label-dropdown" onClick={(e) => e.stopPropagation()}>
                        <div className="dropdown-search">
                            <input
                                type="text"
                                placeholder="Search label..."
                                value={dropdownSearch}
                                onChange={(e) => setDropdownSearch(e.target.value)}
                                autoFocus
                                onClick={(e) => e.stopPropagation()}
                            />
                        </div>
                        {filteredSections.map(section => (
                            <div key={section.key} className="dropdown-section">
                                <div className="dropdown-section-title">{section.title}</div>
                                {section.items.map(item => (
                                    <div 
                                        key={item.abbr}
                                        className="dropdown-item"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            e.preventDefault();
                                            onSelect(item.abbr);
                                        }}
                                    >
                                        <span className="dropdown-item-abbr">{item.abbr}</span>
                                        <span className="dropdown-item-full">{item.full}</span>
                                    </div>
                                ))}
                            </div>
                        ))}
                        {filteredSections.length === 0 && (
                            <div className="dropdown-empty">No results</div>
                        )}
                    </div>
                );
            };

            // Close dropdown on click outside
            const dropdownRef = useRef(null);
            
            useEffect(() => {
                const handleClickOutside = (e) => {
                    // If no dropdown open, do nothing
                    if (!dropdownOpen) return;
                    
                    // Check if click was inside any dropdown or trigger button
                    const clickedDropdown = e.target.closest('.label-dropdown');
                    const clickedTrigger = e.target.closest('.dropdown-trigger');
                    
                    // If click was outside dropdowns and triggers, close
                    if (!clickedDropdown && !clickedTrigger) {
                        setDropdownOpen(null);
                        setDropdownSearch('');
                    }
                };
                
                // Use setTimeout so listener is added after render
                const timeoutId = setTimeout(() => {
                    document.addEventListener('click', handleClickOutside);
                }, 0);
                
                return () => {
                    clearTimeout(timeoutId);
                    document.removeEventListener('click', handleClickOutside);
                };
            }, [dropdownOpen]);

            const renderLabelInput = (node, field, isTop) => {
                const value = (node[field] || '');
                const parts = value.split('/').map(p => p.trim());
                const isSplit = parts.length > 1;
                const hasValue = value.trim() !== '';
                const isEditing = editingLabel === `${node.id}-${field}`;
                const dropdownId = `${node.id}-${field}`;
                const baseClass = `label-input ${isTop ? 'label-top' : ''} ${hasValue ? (isTop ? 'has-value-top' : 'has-value-bottom') : ''}`;

                const setValue = (newVal) => setTree(prev => updateNode(prev, node.id, { [field]: newVal }));

                const toggleSplit = (e) => {
                    e.stopPropagation();
                    if (isSplit) {
                        const left = (parts[0] || '').trim();
                        const right = (parts.slice(1).join('/').trim() || '');
                        setValue((left || right || '').trim());
                    } else {
                        const left = value.trim();
                        setValue((left ? left : '') + ' / ');
                    }
                };

                const startEditing = () => {
                    setEditingLabel(`${node.id}-${field}`);
                };

                const handleBlur = (e) => {
                    const labelWrap = e.currentTarget.closest('.label-wrap');
                    const relatedTarget = e.relatedTarget;
                    
                    // If focus goes to another element in same label-wrap (including dropdown), do not close
                    if (labelWrap && relatedTarget && labelWrap.contains(relatedTarget)) {
                        return;
                    }
                    
                    // If focus goes to dropdown button or dropdown itself, do not close
                    if (relatedTarget && (relatedTarget.closest('.dropdown-trigger') || relatedTarget.closest('.label-dropdown'))) {
                        return;
                    }
                    
                    setTimeout(() => {
                        setEditingLabel(prev => {
                            if (prev === `${node.id}-${field}`) {
                                return null;
                            }
                            return prev;
                        });
                    }, 200);
                };

                const handleKeyDown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        setEditingLabel(null);
                    }
                };

                const handleDropdownSelect = (abbr, partIndex = null) => {
                    if (isSplit && partIndex !== null) {
                        const newParts = [...parts];
                        newParts[partIndex] = abbr;
                        setValue(newParts.join(' / '));
                    } else {
                        setValue(abbr);
                    }
                    setDropdownOpen(null);
                    setDropdownSearch('');
                    // Close edit mode so label shows in display mode
                    setEditingLabel(null);
                };

                const openDropdown = (e, suffix = '') => {
                    e.stopPropagation();
                    e.preventDefault();
                    const newId = dropdownId + suffix;
                    // If this same dropdown is open, close it; otherwise, open it
                    if (dropdownOpen === newId) {
                        setDropdownOpen(null);
                        setDropdownSearch('');
                    } else {
                        setDropdownOpen(newId);
                        setDropdownSearch('');
                    }
                };

                // Edit mode: show inputs with dropdown buttons
                if (isEditing) {
                    return (
                        <div className="label-wrap">
                            {isSplit ? (
                                <>
                                    <div className="label-with-dropdown">
                                        <input
                                            type="text"
                                            value={parts[0] || ''}
                                            onChange={(e) => {
                                                const left = e.target.value;
                                                const right = parts.slice(1).join('/').trim();
                                                setValue(left + ' / ' + right);
                                            }}
                                            onBlur={handleBlur}
                                            onKeyDown={handleKeyDown}
                                            autoFocus
                                            className={baseClass}
                                            style={{ width: '65px' }}
                                            placeholder={isTop ? 'func.' : 'cat.'}
                                        />
                                        <button 
                                            type="button" 
                                            className="dropdown-trigger"
                                            onMouseDown={(e) => e.preventDefault()}
                                            onClick={(e) => openDropdown(e, '-0')}
                                            title="Select label from catalog"
                                        >
                                            â˜°
                                        </button>
                                        {dropdownOpen === `${dropdownId}-0` && (
                                            <LabelDropdown
                                                isTop={isTop}
                                                onSelect={(abbr) => handleDropdownSelect(abbr, 0)}
                                                onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                            />
                                        )}
                                    </div>
                                    <span className="slash-separator" style={{ color: '#6b7280', fontWeight: 'bold', fontSize: '12px' }}>â€¢</span>
                                    <div className="label-with-dropdown">
                                        <input
                                            type="text"
                                            value={parts.slice(1).join('/').trim()}
                                            onChange={(e) => {
                                                const right = e.target.value;
                                                const left = (parts[0] || '').trim();
                                                setValue(left + ' / ' + right);
                                            }}
                                            onBlur={handleBlur}
                                            onKeyDown={handleKeyDown}
                                            className={baseClass}
                                            style={{ width: '65px' }}
                                            placeholder={isTop ? 'func.' : 'cat.'}
                                        />
                                        <button 
                                            type="button" 
                                            className="dropdown-trigger"
                                            onMouseDown={(e) => e.preventDefault()}
                                            onClick={(e) => openDropdown(e, '-1')}
                                            title="Select label from catalog"
                                        >
                                            â˜°
                                        </button>
                                        {dropdownOpen === `${dropdownId}-1` && (
                                            <LabelDropdown
                                                isTop={isTop}
                                                onSelect={(abbr) => handleDropdownSelect(abbr, 1)}
                                                onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                            />
                                        )}
                                    </div>
                                </>
                            ) : (
                                <div className="label-with-dropdown">
                                    <input
                                        type="text"
                                        value={value}
                                        onChange={(e) => setValue(e.target.value)}
                                        onBlur={handleBlur}
                                        onKeyDown={handleKeyDown}
                                        autoFocus
                                        className={baseClass}
                                        style={{ width: '78px' }}
                                        placeholder={isTop ? 'func.' : 'cat.'}
                                    />
                                    <button 
                                        type="button" 
                                        className="dropdown-trigger"
                                        onMouseDown={(e) => e.preventDefault()}
                                        onClick={(e) => openDropdown(e)}
                                        title="Select label from catalog"
                                    >
                                        â˜°
                                    </button>
                                    {dropdownOpen === dropdownId && (
                                        <LabelDropdown
                                            isTop={isTop}
                                            onSelect={(abbr) => handleDropdownSelect(abbr)}
                                            onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                        />
                                    )}
                                </div>
                            )}
                            <button
                                type="button"
                                className="split-toggle-btn"
                                title={isSplit ? 'Merge label' : 'Split label'}
                                onClick={toggleSplit}
                                aria-label={isSplit ? 'Merge label' : 'Split label'}
                            >
                                â‡„
                            </button>
                        </div>
                    );
                }

                // Display mode: show formatted text
                const displayClass = `label-display ${isTop ? 'label-top' : ''} ${hasValue ? 'has-value' : ''}`;

                return (
                    <div className="label-wrap">
                        {isSplit ? (
                            <>
                                <span 
                                    className={displayClass}
                                    style={{ width: '80px', minWidth: '80px' }}
                                    onClick={startEditing}
                                    data-raw-value={parts[0]?.trim() || ''}
                                >
                                    {parts[0]?.trim() ? formatLabelText(parts[0].trim()) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                                </span>
                                <span className="slash-separator" style={{ color: '#6b7280', fontWeight: 'bold', fontSize: '12px' }}>â€¢</span>
                                <span 
                                    className={displayClass}
                                    style={{ width: '80px', minWidth: '80px' }}
                                    onClick={startEditing}
                                    data-raw-value={parts.slice(1).join('/').trim() || ''}
                                >
                                    {parts.slice(1).join('/').trim() ? formatLabelText(parts.slice(1).join('/').trim()) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                                </span>
                            </>
                        ) : (
                            <span 
                                className={displayClass}
                                style={{ width: '95px', minWidth: '95px' }}
                                onClick={startEditing}
                                data-raw-value={value || ''}
                            >
                                {hasValue ? formatLabelText(value) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                            </span>
                        )}
                        <button
                            type="button"
                            className="split-toggle-btn"
                            title={isSplit ? 'Merge label' : 'Split label'}
                            onClick={toggleSplit}
                            aria-label={isSplit ? 'Merge label' : 'Split label'}
                        >
                            â‡„
                        </button>
                    </div>
                );
            };

            // ===========================================
            // NODE RENDERING
            // ===========================================
            const renderNode = (node) => {
                const isDiv = divisionMode === node.id;
                const hasC = node.children && node.children.length > 0;
                const isEmpty = !node.text || node.text.trim() === '';
                const words = node.text ? node.text.split(/\s+/) : [];
                const canDivide = words.length > 1 && !node.isInserted && !node.isConsolidated;
                const canConsolidate = words.length > 1 && !node.isInserted && !hasC;
                // Single-word nodes can be expanded to add children
                const canExpand = words.length === 1 && !node.isInserted && !hasC;
                // Show bold button on terminal nodes (no children)
                const isTerminal = !hasC;

                return (
                    <div
                        className={`node-container ${node.isNucleus ? 'nucleus-node' : ''}`}
                        key={node.id}
                    >
                        {renderLabelInput(node, 'labelTop', true)}
                        
                        {isEmpty ? (
                            <div className="connector-v" style={{ height: '36px' }} />
                        ) : (
                            <>
                                <div className="connector-v" style={{ height: '12px' }} />
                                
                                {isDiv ? (
                                    <div style={{background:'#f8fafc', padding:'15px', border:'1px solid #374151', borderRadius:'4px'}}>
                                        <div style={{display:'flex', gap:'4px', marginBottom:'10px'}}>
                                            {words.map((w, i) => (
                                                <React.Fragment key={i}>
                                                    <span style={{padding:'6px 10px', background:'white', border:'1px solid #cbd5e1'}}>{w}</span>
                                                    {i < words.length - 1 && (
                                                        <button
                                                            onClick={() => setSelectedCuts(prev => prev.includes(i) ? prev.filter(x => x !== i) : [...prev, i].sort((a, b) => a - b))}
                                                            style={{width:'10px', background: selectedCuts.includes(i) ? '#374151' : '#e2e8f0', border:'none', cursor:'pointer'}}
                                                        />
                                                    )}
                                                </React.Fragment>
                                            ))}
                                        </div>
                                        <div style={{display:'flex', gap:'8px', justifyContent:'center'}}>
                                            <button onClick={handleDivide} className="btn btn-primary" style={{padding:'5px 12px'}}>Divide</button>
                                            <button onClick={() => setDivisionMode(null)} className="btn btn-outline" style={{padding:'5px 12px'}}>Cancel</button>
                                        </div>
                                    </div>
                                ) : (
	                                    <div className="node-box-row">
                                        <div
                                            className={`node-box ${canDivide ? 'can-divide' : ''}`}
                                            onClick={() => !hasC && canDivide && setDivisionMode(node.id)}
                                        >
                                            {node.text}
                                            {canConsolidate && (
                                                <button
                                                    className="consolidate-btn"
                                                    title={node.isConsolidated ? "Allow division" : "Consolidate (do not divide)"}
                                                    onClick={(e) => { e.stopPropagation(); toggleConsolidated(node.id); }}
                                                >
                                                    {node.isConsolidated ? 'Ã·' : 'âˆª'}
                                                </button>
                                            )}
                                            {canExpand && (
                                                <button
                                                    className="consolidate-btn"
                                                    title="Expand (add constituents)"
                                                    onClick={(e) => { e.stopPropagation(); expandNode(node.id); }}
                                                >
                                                    Ã·
                                                </button>
                                            )}
                                            {hasC && !node.isInserted && (
                                                <button
                                                    className="add-node-btn"
                                                    title="Add child node"
                                                    onClick={(e) => { e.stopPropagation(); addChildNode(node.id); }}
                                                >
                                                    +
                                                </button>
                                            )}
                                            {hasC && (
                                                <button
                                                    className="clear-text-btn"
                                                    onClick={(e) => { e.stopPropagation(); setTree(prev => updateNode(prev, node.id, { text: '' })); }}
                                                >
                                                    âœ•
                                                </button>
                                            )}
                                            {isTerminal && (
                                                <button
                                                    className={`nucleus-toggle-btn ${node.isNucleus ? 'is-nucleus' : ''}`}
                                                    title={node.isNucleus ? "Remove bold (head)" : "Mark as head (bold)"}
                                                    onClick={(e) => { 
                                                        e.stopPropagation(); 
                                                        setTree(prev => updateNode(prev, node.id, { isNucleus: !node.isNucleus })); 
                                                    }}
                                                >
                                                    H
                                                </button>
                                            )}
                                        </div>
                                        {hasC && (
                                            <button
                                                className="btn-danger-soft node-revert-btn"
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setTree(prev => updateNode(prev, node.id, { children: null }));
                                                }}
                                                title="Undo division"
                                                aria-label="Undo division"
                                            >
                                                â†©
                                            </button>
                                        )}</div>
                                )}
                                
                                <div className="connector-v" style={{ height: '12px' }} />
                            </>
                        )}

                        {renderLabelInput(node, 'labelBottom', false)}
                        
                        {hasC && (
                            <div style={{display:'flex', flexDirection:'column', alignItems:'center', width:'100%'}}>
                                <div className="connector-v" style={{height:'24px'}} />
                                <div className="children-container">
                                    {node.children.map((c) => (
                                        <div className="child-branch" key={c.id}>
                                            <div className="v-line-stem" />
                                            {renderNode(c)}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            // ===========================================
            // STATIC RENDERING (COMPARISON)
            // ===========================================
            const renderStaticNode = (node, comparisons, path = 'root', isModel = false) => {
                const comparison = comparisons?.get(path);

                // For student tree, if no node, render nothing
                // (no longer creating ghost nodes âˆ…)
                if (!node) return null;

                const isEmpty = !node.text || node.text.trim() === '';

                let nodeClass = 'node-container';
                if (node.isNucleus) nodeClass += ' nucleus-node';

                // Color node based on whether it was IDENTIFIED correctly (not based on division)
                // A green node means student correctly identified this constituent
                if (!isModel && comparison) {
                    nodeClass += comparison.nodeCorrect ? ' node-correct' : ' node-incorrect';
                }

                const modelTop = comparison?.modelNode?.labelTop?.trim() || '';
                const modelBottom = comparison?.modelNode?.labelBottom?.trim() || '';
                const studentTop = (node.labelTop || '').trim();
                const studentBottom = (node.labelBottom || '').trim();

                const shouldShowTop = isModel ? !!studentTop : (!!studentTop || !!modelTop);
                const shouldShowBottom = isModel ? !!studentBottom : (!!studentBottom || !!modelBottom);

                const labelTopClass = (!isModel && comparison && (studentTop || modelTop))
                    ? (comparison.labelTopMatch ? 'label-correct' : 'label-incorrect')
                    : '';

                const labelBottomClass = (!isModel && comparison && (studentBottom || modelBottom))
                    ? (comparison.labelBottomMatch ? 'label-correct' : 'label-incorrect')
                    : '';

                const renderStaticLabel = (valueToShow, isTop, extraClass) => {
                    if (!valueToShow || !valueToShow.trim()) return null;
                    const showAsEmpty = valueToShow.trim() === 'âˆ…';
                    
                    // Format value to show â€¢ instead of / as separator
                    const displayValue = valueToShow.split('/').map(p => p.trim()).filter(p => p).join(' â€¢ ');

                    return (
                        <div
                            className={extraClass}
                            style={{
                                width: '95px',
                                textAlign: 'center',
                                padding: '4px',
                                fontSize: '11px',
                                borderRadius: '4px',
                                textTransform: isTop ? 'uppercase' : 'none',
                                fontStyle: showAsEmpty ? 'italic' : 'normal',
                                opacity: showAsEmpty ? 0.9 : 1,
                                backgroundColor: extraClass ? undefined : '#f1f5f9',
                                border: extraClass ? undefined : '1px solid #cbd5e1',
                                color: extraClass ? undefined : '#334155'
                            }}
                        >
                            {displayValue}
                        </div>
                    );
                };

                // Determine which children to render
                let childrenToRender = [];
                
                // If model, or if division is correct, show children
                if (isModel || (comparison && comparison.divisionCorrect)) {
                    const children = node.children || [];
                    const normalizeLabel = (label) => {
                        if (!label) return '';
                        return label.split('/')
                            .map(p => p.trim().toLowerCase().replace(/\s+/g, ''))
                            .filter(p => p)
                            .sort()
                            .join('â€¢');
                    };
                    
                    // Count separate indices for normal and extra nodes
                    let normalIndex = 0;
                    let extraIndex = 0;
                    
                    if (isModel) {
                        // For model: traverse in original order, assigning paths by type
                        children.forEach((c) => {
                            if (c.isInserted) {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-e${extraIndex}`
                                });
                                extraIndex++;
                            } else {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-n${normalIndex}`
                                });
                                normalIndex++;
                            }
                        });
                    } else {
                        // For student: traverse in original order, but match extras by labels
                        const modelExtra = (comparison?.modelNode?.children || []).filter(c => c.isInserted);
                        
                        // Create map from model labels to index
                        const modelExtraByLabels = new Map();
                        modelExtra.forEach((mc, mi) => {
                            const key = normalizeLabel(mc.labelTop) + '|' + normalizeLabel(mc.labelBottom);
                            if (!modelExtraByLabels.has(key)) {
                                modelExtraByLabels.set(key, mi);
                            }
                        });
                        
                        const usedModelExtraIndices = new Set();
                        
                        children.forEach((c) => {
                            if (c.isInserted) {
                                // Find model index corresponding to this extra node by labels
                                const key = normalizeLabel(c.labelTop) + '|' + normalizeLabel(c.labelBottom);
                                let modelIdx = modelExtraByLabels.get(key);
                                
                                // If that index already used, find another with same labels
                                if (modelIdx !== undefined && usedModelExtraIndices.has(modelIdx)) {
                                    modelIdx = undefined;
                                    for (let mi = 0; mi < modelExtra.length; mi++) {
                                        if (usedModelExtraIndices.has(mi)) continue;
                                        const mKey = normalizeLabel(modelExtra[mi].labelTop) + '|' + normalizeLabel(modelExtra[mi].labelBottom);
                                        if (mKey === key) {
                                            modelIdx = mi;
                                            break;
                                        }
                                    }
                                }
                                
                                if (modelIdx !== undefined) {
                                    usedModelExtraIndices.add(modelIdx);
                                    childrenToRender.push({ 
                                        node: c, 
                                        path: `${path}-e${modelIdx}`
                                    });
                                }
                            } else {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-n${normalIndex}`
                                });
                                normalIndex++;
                            }
                        });
                    }
                }
                // If division error (shouldTruncate), do not show children, only message

                return (
                    <div className={nodeClass} key={node.id || path}>
                        {shouldShowTop && renderStaticLabel(
                            isModel ? studentTop : (studentTop || (modelTop ? 'âˆ…' : '')), 
                            true, 
                            labelTopClass
                        )}

                        {isEmpty ? (
                            <div className="connector-v" style={{ height: '36px' }} />
                        ) : (
                            <>
                                <div className="connector-v" style={{ height: '12px' }} />
                                <div className="node-box" style={{ cursor: 'default' }}>
                                    {node.text}
                                </div>
                                {/* Only show bottom line if there is bottom label, children, or error message */}
                                {(shouldShowBottom || childrenToRender.length > 0 || (!isModel && comparison?.shouldTruncate)) && (
                                    <div className="connector-v" style={{ height: '12px' }} />
                                )}
                            </>
                        )}

                        {shouldShowBottom && renderStaticLabel(
                            isModel ? studentBottom : (studentBottom || (modelBottom ? 'âˆ…' : '')), 
                            false, 
                            labelBottomClass
                        )}

                        {/* If division error, show message and truncate */}
                        {!isModel && comparison?.shouldTruncate ? (
                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                <div className="connector-v" style={{ height: '24px' }} />
                                <div style={{
                                    padding: '8px 16px',
                                    backgroundColor: '#fef2f2',
                                    border: '2px solid #ef4444',
                                    borderRadius: '6px',
                                    color: '#b91c1c',
                                    fontSize: '12px',
                                    fontWeight: 'bold',
                                    textAlign: 'center',
                                    maxWidth: '150px',
                                    boxShadow: '0 2px 4px rgba(0,0,0,0.05)'
                                }}>
                                    Constituent incorrectly divided
                                </div>
                            </div>
                        ) : (
                            /* If division is correct (or is model), show children */
                            childrenToRender.length > 0 && (
                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                    <div className="connector-v" style={{ height: '24px' }} />
                                    <div className="children-container">
                                        {childrenToRender.map((item, i) => (
                                            <div className="child-branch" key={(item.node?.id) || item.path || i}>
                                                <div className="v-line-stem" />
                                                {renderStaticNode(item.node, comparisons, item.path, isModel)}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )
                        )}
                    </div>
                );
            };

            // ===========================================
            // FOOTER COMPONENT
            // ===========================================
            const Footer = () => (
                <footer className="footer">
                    <p>Carlos GonzÃ¡lez Vergara (<strong><a href="mailto:cgonzalv@uc.cl">cgonzalv@uc.cl</a></strong>)</p>
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer">
                        <img 
                            src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nc-nd.svg" 
                            alt="CC BY-NC-ND 4.0" 
                        />
                    </a>
                </footer>
            );

            // ===========================================
            // COMPARISON VIEW
            // ===========================================
            if (showComparison && comparisonResults) {
                return (
                    <div className="container">
                        <header className="header-logo-container">
                            <img src="english_logo.png" alt="ENT - Syntactic Analysis Assistant" className="header-logo" />
                        </header>

                        {/* Language selector */}
                        <div className="language-selector">
                            <a href="index.html">
                                <img src="spain_grey.png" alt="EspaÃ±ol" className="language-flag inactive" title="Cambiar a EspaÃ±ol" />
                            </a>
                            <img src="uk_solid.png" alt="English" className="language-flag active" title="English (current)" />
                        </div>

                        <div className="exercise-banner">
                            <div className="exercise-banner-text">
                                
                                <div>
                                    <div className="exercise-badge">ðŸ“š <strong>Exercise mode</strong></div>
                                    <p>You are viewing results. You can go back to edit or exit exercise mode.</p>
                                </div>
                            </div>
                            <button onClick={resetExercise} className="btn btn-outline">Exit exercise mode</button>
                        </div>

                        <div className="results-summary">
                            <h3>Results</h3>
                            <div className="results-stats" style={{ marginBottom: '14px' }}>
                                <div className="stat-item">
                                    <span className="stat-dot correct"></span>
                                    <strong>Correct:</strong>&nbsp;
                                    {comparisonResults.correctElements} / {comparisonResults.totalElements}
                                </div>
                                <div className="stat-item">
                                    <span className="stat-dot incorrect"></span>
                                    <strong>Errors:</strong>&nbsp;
                                    {comparisonResults.errorElements}
                                </div>
                                <div className="stat-item">
                                    <span className="stat-dot partial"></span>
                                    <strong>Accuracy:</strong>&nbsp;
                                    {(comparisonResults.accuracy * 100).toFixed(0)}%
                                </div>
                            </div>
                            <p style={{margin: 0, fontSize: '15px', color: '#374151', lineHeight: '1.6'}}>
                                <ul>
                                    <li>Constituents in <span style={{color: '#10b981'}}>green</span> have correct structure; 
                                    those in <span style={{color: '#ef4444'}}>red</span> have structural differences. </li>
                                    <li>Labels in <span style={{color: '#10b981'}}>green</span> have correct information;
                                    those in <span style={{color: '#ef4444'}}>red</span> differ from the model.  </li>
                                </ul>
                            </p>
                        </div>

                        <div className="comparison-container">
                            <div className="comparison-panel student">
                                <h3>âœŽ Your analysis</h3>
                                <div className="comparison-tree">
                                    <div className="tree-wrapper">
                                        {renderStaticNode(tree, comparisonResults.nodeComparisons, 'root', false)}
                                    </div>
                                </div>
                            </div>
                            <div className="comparison-panel model">
                                <h3>âœ“ Model analysis</h3>
                                <div className="comparison-tree">
                                    <div className="tree-wrapper">
                                        {renderStaticNode(modelTree, null, 'root', true)}
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="bottom-actions">
                            <button onClick={() => setShowComparison(false)} className="btn btn-outline">â† Back to edit</button>
                            <button onClick={newExercise} className="btn btn-primary">New exercise</button>
                        </div>

                        <Footer />
                    </div>
                );
            }

            // ===========================================
            // MAIN VIEW
            // ===========================================
            return (
                <div className="container">
                    <header className="header-logo-container">
                        <img src="english_logo.png" alt="ENT - Syntactic Analysis Assistant" className="header-logo" />
                    </header>

                    {/* Language selector */}
                        <div className="language-selector">
                            <a href="index.html">
                                <img src="spain_grey.png" alt="EspaÃ±ol" className="language-flag inactive" title="Cambiar a EspaÃ±ol" />
                            </a>
                            <img src="uk_solid.png" alt="English" className="language-flag active" title="English (current)" />
                        </div>    

                    {exerciseMode && !modelTree && (
                        <div className="exercise-banner" style={{flexDirection: 'column', alignItems: 'center', padding: '40px'}}>
                            <div className="exercise-banner-text">
                                
                                <div>
                                    <div className="exercise-badge">ðŸ“š <strong>Exercise mode</strong></div>
                                    <p>Analyze the expression and compare your result with the model when done</p>
                                </div>
                            </div>
                            <p style={{marginBottom: '16px', color: '#6b7280'}}>Select an exercise from your computer or from the example bank</p>
                            
                            <div style={{display: 'flex', gap: '12px', marginBottom: '16px'}}>
                                <button onClick={() => exerciseInputRef.current.click()} className="btn btn-primary">ðŸ“‚ Load local file</button>
                                <button onClick={() => { setShowFilesModal(true); setFilesActiveTab('cloud'); }} className="btn btn-primary">â˜ï¸ Example bank</button>
                            </div>
                            
                            {driveFiles.length > 0 && (
                                <div style={{width: '100%', maxWidth: '500px', marginBottom: '16px'}}>
                                    <div className="drive-files-list" style={{maxHeight: '200px'}}>
                                        {driveFiles.map((folder, idx) => (
                                            folder.folderName ? (
                                                <div className="drive-folder" key={folder.folderId || idx}>
                                                    <div 
                                                        className="drive-folder-header"
                                                        onClick={() => toggleFolder(folder.folderId)}
                                                    >
                                                        <span className={`drive-folder-toggle ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>â–¼</span>
                                                        ðŸ“ {folder.folderName}
                                                        <span style={{marginLeft: 'auto', fontSize: '11px', color: '#9ca3af'}}>
                                                            {folder.files.length} file{folder.files.length !== 1 ? 's' : ''}
                                                        </span>
                                                    </div>
                                                    <div className={`drive-folder-content ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>
                                                        {folder.files.map(file => (
                                                            <div 
                                                                key={file.id}
                                                                className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                onClick={() => setSelectedDriveFile(file)}
                                                            >
                                                                <span className="drive-file-icon">ðŸ“„</span>
                                                                <span className="drive-file-name">{file.name}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="drive-root-files" key="root">
                                                    {folder.files.map(file => (
                                                        <div 
                                                            key={file.id}
                                                            className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                            onClick={() => setSelectedDriveFile(file)}
                                                        >
                                                            <span className="drive-file-icon">ðŸ“„</span>
                                                            <span className="drive-file-name">{file.name}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            )
                                        ))}
                                    </div>
                                    {selectedDriveFile && (
                                        <div style={{marginTop: '12px', textAlign: 'center'}}>
                                            <button 
                                                className="btn btn-exercise"
                                                onClick={() => handleLoadFromDrive(true)}
                                            >
                                                ðŸ“š Start exercise with "{selectedDriveFile.name}"
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            <button onClick={resetExercise} className="btn btn-outline">Exit exercise mode</button>
                        </div>
                    )}

                    {exerciseMode && modelTree && (
                        <div className="exercise-banner">
                            <div className="exercise-banner-text">
                                <div>
                                    <div className="exercise-badge">ðŸ“š <strong>Exercise mode</strong></div>
                                    <p>Analyze the expression and compare your result with the model when done</p>
                                </div>
                            </div>
                            <button onClick={resetExercise} className="btn btn-outline">Exit exercise mode</button>
                        </div>
                    )}

                    <div className="input-section">
                        <div className="input-row">
                            {!exerciseMode ? (
                                <>
                                    <input 
                                        type="text" 
                                        value={sentence} 
                                        onChange={(e) => setSentence(e.target.value)} 
                                        placeholder="Type the expression you want to analyze" 
                                        onKeyPress={(e) => e.key === 'Enter' && startAnalysis()} 
                                    />
                                    <button onClick={startAnalysis} className="btn btn-primary">Analyze</button>
                                    <button 
                                        onClick={handleUndo} 
                                        className="btn btn-outline btn-icon" 
                                        disabled={!canUndo}
                                        title="Undo (Ctrl+Z)"
                                    >
                                        â†¶
                                    </button>
                                    <button 
                                        onClick={handleRedo} 
                                        className="btn btn-outline btn-icon" 
                                        disabled={!canRedo}
                                        title="Redo (Ctrl+Shift+Z)"
                                    >
                                        â†·
                                    </button>
                                    <span className="btn-separator"></span>
                                    <button onClick={() => setShowFilesModal(true)} className="btn btn-outline">ðŸ“ Files</button>
                                    <input type="file" ref={fileInputRef} style={{display:'none'}} accept=".ent,.json,application/json,text/plain,*/*" onChange={handleLoadJSON} />
                                    <span className="btn-separator"></span>
                                    <button onClick={() => setExerciseMode(true)} className="btn btn-exercise">ðŸ“š Exercise mode</button>
                                    <span className="btn-separator"></span>
                                    <button 
                                        onClick={() => window.open('english_manual.html', '_blank')} 
                                        className="btn btn-outline"
                                        title="View detailed manual"
                                    >
                                        ðŸ—‚ Manual
                                    </button>
                                </>
                            ) : (
                                modelTree && (
                                    <div style={{flex: 1, padding: '8px 16px', backgroundColor: '#f3f4f6', borderRadius: '6px', fontSize: '15px', color: '#374151'}}>
                                        <strong>Expression to analyze:</strong> {sentence}
                                    </div>
                                )
                            )}
                        </div>
                        <input type="file" ref={exerciseInputRef} style={{display:'none'}} accept=".ent,.json,application/json,text/plain,*/*" onChange={handleLoadExercise} />
                    </div>

                    {!(exerciseMode && !modelTree) && (
                        <div className="tree-container">
                            {tree ? (
                                <div className="tree-wrapper">{renderNode(tree)}</div>
                            ) : (
                                <p style={{textAlign:'center', color:'#9ca3af', marginTop:'100px'}}>
                                    Type an expression or load an .ent file to edit it
                                </p>
                            )}
                        </div>
                    )}

                    {tree && (
                        <div className="bottom-actions">
                            {exerciseMode ? (
                                <>
                                    <button onClick={newExercise} className="btn btn-outline">Cancel exercise</button>
                                    <button onClick={handleFinishExercise} className="btn btn-success">âœ“ Finish analysis and compare</button>
                                </>
                            ) : (
                                <>
                                    <button onClick={() => { setTree(null); setSentence(''); setHistory([]); setHistoryIndex(-1); }} className="btn btn-new-analysis">âœ¦ New analysis</button>
                                    <button onClick={handleSaveJSON} className="btn btn-outline" disabled={!tree} title="Save (Ctrl+S)">ðŸ’¾ Save .ent</button>
                                    <button onClick={() => handleExport(false)} className="btn btn-primary">Export diagram</button>
                                    <button onClick={() => handleExport(true)} className="btn btn-primary">Export tree diagram</button>
                                </>
                            )}
                        </div>
                    )}

                    <div className="instructions-panel">
                        <div 
                            className="instructions-header" 
                            onClick={() => setInstructionsCollapsed(!instructionsCollapsed)}
                        >
                            <span>Quick guide</span>
                            <span className={`instructions-toggle ${instructionsCollapsed ? 'collapsed' : ''}`}>â–¼</span>
                        </div>
                        <div className={`instructions-content ${instructionsCollapsed ? 'collapsed' : ''}`}>
                            <div className="instructions-grid">
                                
                                <div className="instruction-card">
                                    <h4><span className="icon">âœ‚</span> Constituents</h4>
                                    <ul>
                                        <li>Click on a <strong>light blue box</strong> to divide a syntactic structure into constituents.</li>
                                        <li>Click on the <strong>gray bars</strong> between words to mark boundaries between constituents.</li>
                                        <li>Click <code>â†©</code> next to a light blue box to revert the division.</li>
                                        <li>Hover over a terminal node (word) and click <code>H</code> to mark it as <strong>head</strong> (bold).</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">â˜–</span> Labels</h4>
                                    <ul>
                                        <li>In the <strong>top</strong> label, write the grammatical function (SUBJ, DO, IO, HEAD, DET, etc.).</li>
                                        <li>In the <strong>bottom</strong> label, write the category (N, V, NP, VP, etc.).</li>
                                        <li>If you prefer, click <code>â˜°</code> to select predefined labels.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">â‡„</span> Split labels</h4>
                                    <ul>
                                        <li>Hover over the label and click <code>â‡„</code> to split or merge.</li>
                                        <li>Useful for analyses with multiple functions or categories.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">ï¼‹</span> Add extra constituents</h4>
                                    <ul>
                                        <li>Hover over the node under which you want to create an extra constituent and click <code>+</code>.</li>
                                        <li>Type the text and choose the position to insert it.</li>
                                        <li>Useful for adding elided constituents.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">Aa</span> Text formatting</h4>
                                    <ul>
                                        <li><code>*text*</code> for <em>italics</em></li>
                                        <li><code>**text**</code> for <strong>bold</strong></li>
                                        <li><code>_text_</code> for <sub>subscript</sub></li>
                                        <li><code>Â¨textÂ¨</code> for <sup>superscript</sup></li>
                                    </ul>
                                </div> 

                                <div className="instruction-card">
                                    <h4><span className="icon">âŒ˜</span> Keyboard shortcuts</h4>
                                            <div style={{ display: 'flex', justifyContent: 'flex-start', gap: '40px', marginTop: '8px' }}>
                                            <ul className="shortcut-list">
                                                <li style={{ marginBottom: '10px', opacity: 0.7, fontSize: '11px', fontWeight: 'bold', color: '#6b7280' }}>WINDOWS / LINUX</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">Z</span> Undo</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">Y</span> Redo</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">S</span> Save</li>
                                            </ul>

                                            <ul className="shortcut-list">
                                                <li style={{ marginBottom: '10px', opacity: 0.7, fontSize: '11px', fontWeight: 'bold', color: '#6b7280' }}>macOS</li>
                                                <li><span className="key">âŒ˜</span>+<span className="key">Z</span> Undo</li>
                                                <li><span className="key">âŒ˜</span>+<span className="key">â‡§</span>+<span className="key">Z</span> Redo</li>
                                                <li><span className="key">âŒ˜</span>+<span className="key">S</span> Save</li>
                                            </ul>
                                        </div>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">âˆª</span> Consolidate nodes</h4>
                                    <ul>
                                        <li>Hover over a light blue node and click <code>âˆª</code> to consolidate it.</li>
                                        <li>Useful for phrasal verbs or multi-word expressions that should not be syntactically divided.</li>
                                        <li>Click <code>Ã·</code> to allow division again.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">Ã·</span> Expand nodes</h4>
                                    <ul>
                                        <li>Hover over a terminal node and click <code>Ã·</code> to expand it.</li>
                                        <li>A child with the same text is created. Use <code>+</code> to add extra constituents.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">â—°</span> Files</h4>
                                    <ul>
                                        <li>Click <strong>ðŸ“ Files</strong> to open the file manager.</li>
                                        <li><strong>Local</strong> tab: save or load <code>.ent</code> files from your computer.</li>
                                        <li><strong>Example bank</strong> tab: connect to Google Drive to access shared examples.</li>
                                        <li>Shortcut: <span className="key">Ctrl</span>/<span className="key">âŒ˜</span>+<span className="key">S</span> saves directly.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">â˜·</span> Example bank</h4>
                                    <ul>
                                        <li>To create an example bank, upload <code>.ent</code> files to a Google Drive folder.</li>
                                        <li>Right-click the folder â†’ <strong>Share</strong> â†’ <strong>Anyone with the link</strong> (as Viewer).</li>
                                        <li>Copy the link and share it with your students.</li>
                                        <li>You can organize examples in subfolders (by topic, difficulty, etc.).</li>
                                    </ul>
                                </div>

                                {!exerciseMode && (
                                <div className="instruction-card">
                                    <h4><span className="icon">âœŽ</span> Exercise mode</h4>
                                    <ul>
                                        <li>Click <strong>ðŸ“š Exercise mode</strong> to practice.</li>
                                        <li>Load an exercise from your computer or from an <strong>example bank</strong> on Google Drive.</li>
                                        <li>Analyze the given expression and compare your result with the model.</li>
                                    </ul>
                                </div>
                                )}

                                {exerciseMode && (
                                <div className="instruction-card">
                                    <h4 style={{color: '#5b21b6'}}><span className="icon" style={{backgroundColor: '#5b21b6'}}>âœŽ</span> Active exercise</h4>
                                    <ul>
                                        <li>Complete the analysis of the expression.</li>
                                        <li>Use <strong>Compare</strong> to see the solution.</li>
                                    </ul>
                                </div>
                                )}

                            </div>
                        </div>
                    </div>

                    {showFilesModal && (
                        <div className="pos-overlay" onClick={() => setShowFilesModal(false)}>
                            <div className="files-modal" onClick={(e) => e.stopPropagation()}>
                                <div className="files-modal-header">
                                    <h4 className="files-modal-title">{exerciseMode ? 'â˜ï¸ Example bank' : 'ðŸ“ Files'}</h4>
                                    {!exerciseMode && (
                                        <div className="files-tabs">
                                            <button 
                                                className={`files-tab ${filesActiveTab === 'local' ? 'active' : ''}`}
                                                onClick={() => setFilesActiveTab('local')}
                                            >
                                                ðŸ’» Local
                                            </button>
                                            <button 
                                                className={`files-tab ${filesActiveTab === 'cloud' ? 'active' : ''}`}
                                                onClick={() => setFilesActiveTab('cloud')}
                                            >
                                                â˜ï¸ Example bank
                                            </button>
                                        </div>
                                    )}
                                </div>

                                <div className="files-modal-body">
                                    {!exerciseMode && filesActiveTab === 'local' && (
                                        <div className="files-section">
                                            <div className="files-section-title">Local file management</div>
                                            <div className="files-btn-row">
                                                <button 
                                                    onClick={() => { fileInputRef.current.click(); setShowFilesModal(false); }} 
                                                    className="btn btn-outline"
                                                >
                                                    ðŸ“‚ Load .ent
                                                </button>
                                                <button 
                                                    onClick={() => { handleSaveJSON(); setShowFilesModal(false); }} 
                                                    className="btn btn-primary" 
                                                    disabled={!tree}
                                                    title="Save (Ctrl+S)"
                                                >
                                                    ðŸ’¾ Save .ent
                                                </button>
                                            </div>
                                            <p className="files-help-text">
                                                <code>.ent</code> files save your complete analysis (expression, structure and labels).
                                            </p>
                                        </div>
                                    )}

                                    {(exerciseMode || filesActiveTab === 'cloud') && (
                                        <div className="files-section">
                                            <div className="files-section-title">Connect to Google Drive</div>
                                            <div className="drive-connect-row">
                                                <input 
                                                    type="text"
                                                    className="drive-url-input"
                                                    placeholder="Google Drive folder URL..."
                                                    value={driveUrl}
                                                    onChange={(e) => setDriveUrl(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleConnectDrive()}
                                                />
                                                <button 
                                                    className="btn btn-primary" 
                                                    onClick={handleConnectDrive}
                                                    disabled={!driveUrl.trim()}
                                                >
                                                    Connect
                                                </button>
                                            </div>
                                            <p className="files-help-text">
                                                Paste the URL of a public Google Drive folder containing <code>.ent</code> files.<br/>
                                                The folder must be shared as "Anyone with the link".<br/><br/>
                                                Don't have a folder or link? Try the <a 
                                                    href="#" 
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setDriveUrl('https://drive.google.com/drive/folders/1faSpC1f2qUUJag87xRVKuJf2VBk--d7r?usp=share_link');
                                                        setTimeout(() => handleConnectDrive(), 100);
                                                    }}
                                                    style={{color: '#3b82f6', textDecoration: 'underline', cursor: 'pointer'}}
                                                >ENT example bank</a>.
                                            </p>

                                            {driveStatus.type && (
                                                <div className={`drive-status ${driveStatus.type}`}>
                                                    {driveStatus.type === 'loading' && <div className="drive-spinner"></div>}
                                                    {driveStatus.type === 'error' && <span>âš ï¸</span>}
                                                    {driveStatus.type === 'success' && <span>âœ“</span>}
                                                    <span>{driveStatus.message}</span>
                                                </div>
                                            )}

                                            {driveFiles.length > 0 && (
                                                <>
                                                    <div className="files-section-title" style={{marginTop: '16px'}}>Available files</div>
                                                    <div className="drive-files-list">
                                                        {driveFiles.map((folder, idx) => (
                                                            folder.folderName ? (
                                                                <div className="drive-folder" key={folder.folderId || idx}>
                                                                    <div 
                                                                        className="drive-folder-header"
                                                                        onClick={() => toggleFolder(folder.folderId)}
                                                                    >
                                                                        <span className={`drive-folder-toggle ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>â–¼</span>
                                                                        ðŸ“ {folder.folderName}
                                                                        <span style={{marginLeft: 'auto', fontSize: '11px', color: '#9ca3af'}}>
                                                                            {folder.files.length} file{folder.files.length !== 1 ? 's' : ''}
                                                                        </span>
                                                                    </div>
                                                                    <div className={`drive-folder-content ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>
                                                                        {folder.files.map(file => (
                                                                            <div 
                                                                                key={file.id}
                                                                                className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                                onClick={() => setSelectedDriveFile(file)}
                                                                            >
                                                                                <span className="drive-file-icon">ðŸ“„</span>
                                                                                <span className="drive-file-name">{file.name}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            ) : (
                                                                <div className="drive-root-files" key="root">
                                                                    {folder.files.map(file => (
                                                                        <div 
                                                                            key={file.id}
                                                                            className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                            onClick={() => setSelectedDriveFile(file)}
                                                                        >
                                                                            <span className="drive-file-icon">ðŸ“„</span>
                                                                            <span className="drive-file-name">{file.name}</span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            )
                                                        ))}
                                                    </div>

                                                    {selectedDriveFile && (
                                                        <div className="drive-load-options">
                                                            {!exerciseMode && (
                                                                <button 
                                                                    className="btn btn-outline"
                                                                    onClick={() => handleLoadFromDrive(false)}
                                                                >
                                                                    ðŸ“– Load as reference
                                                                </button>
                                                            )}
                                                            <button 
                                                                className="btn btn-exercise"
                                                                onClick={() => handleLoadFromDrive(true)}
                                                            >
                                                                ðŸ“š Load as exercise
                                                            </button>
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                    )}
                                </div>

                                <div className="files-modal-footer">
                                    <button className="btn btn-outline" onClick={() => setShowFilesModal(false)}>Close</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {posPicker && (
                        <div className="pos-overlay" onClick={() => setPosPicker(null)}>
                            <div className="pos-modal" onClick={(e) => e.stopPropagation()}>
                                <h4 className="pos-title">Where do you want the new constituent?</h4>
                                <p className="pos-sub">Choose the position to insert it among the current constituents.</p>
                                <div className="pos-row">
                                    <select
                                        className="pos-select"
                                        value={posPicker.pos}
                                        onChange={(e) => setPosPicker(pp => ({ ...pp, pos: parseInt(e.target.value, 10) }))}
                                    >
                                        {Array.from({ length: posPicker.siblings.length + 1 }, (_, idx) => {
                                            const i = idx + 1;
                                            return (
                                                <option key={i} value={i}>{buildPosLabel(i, posPicker.siblings)}</option>
                                            );
                                        })}
                                    </select>
                                </div>
                                <div className="pos-actions">
                                    <button className="btn btn-outline" onClick={() => setPosPicker(null)}>Cancel</button>
                                    <button className="btn btn-primary" onClick={confirmInsertAtPosition}>Insert</button>
                                </div>
                            </div>
                        </div>
                    )}

                    <Footer />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SyntaxTreeBuilder />);
    </script>
</body>
</html>