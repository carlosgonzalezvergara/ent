<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENT - Asistente para el análisis sintáctico</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* ===========================================
           VARIABLES Y RESET
           =========================================== */
        :root {
            --btn-primary-bg: #374151;
            --btn-primary-bg-hover: #1f2937;
            --btn-primary-text: #ffffff;
            --btn-outline-bg: #ffffff;
            --btn-outline-border: #d1d5db;
            --btn-outline-border-hover: #cbd5e1;
            --btn-outline-text: #374151;
            --btn-exercise-border: #a78bfa;
            --btn-exercise-text: #5b21b6;
            --btn-exercise-bg-hover: #f5f3ff;
            --btn-success-bg: #047857;
            --btn-success-bg-hover: #065f46;
            --ent-text-scale: 1;
        }

        * { box-sizing: border-box; }
        
        body { 
            margin: 0; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            background-color: #f3f4f6; 
            min-height: 100vh; 
            color: #374151; 
        }

        /* ===========================================
           LAYOUT PRINCIPAL
           =========================================== */
        .container { 
            position: relative;
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px 24px 32px; 
        }

        .header-logo-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-logo {
            max-width: 380px;
            width: 100%;
            height: auto;
        }

        /* ===========================================
        SELECTOR DE IDIOMA
        =========================================== */
        .language-selector {
            position: absolute;
            top: 20px;
            right: 24px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
        }

        .language-selector a {
            display: flex;
            align-items: center;
        }

        .language-flag {
            height: 28px;
            width: auto;
            border-radius: 3px;
            transition: opacity 0.2s ease, transform 0.2s ease;
            display: block;
        }

        .language-flag.active {
            opacity: 1;
            cursor: default;
        }

        .language-flag.inactive {
            opacity: 0.7;
            cursor: pointer;
        }

        .language-flag.inactive:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .input-section { 
            background: white; 
            border-radius: 8px; 
            padding: 24px; 
            margin-bottom: 24px; 
            border: 1px solid #e5e7eb; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
        }

        .input-row { 
            display: flex; 
            gap: 12px; 
            align-items: center; 
            flex-wrap: wrap; 
        }

        .input-row input[type="text"] { 
            flex: 1; 
            padding: 12px 16px; 
            border: 1px solid #d1d5db; 
            border-radius: 6px; 
            font-size: 15px; 
            min-width: 200px; 
        }

        /* ===========================================
           BOTONES
           =========================================== */
        .btn {
            padding: 10px 20px;
            border: 1px solid transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            line-height: 1;
            user-select: none;
        }

        .btn:active { transform: translateY(1px); }
        .btn:focus-visible { outline: 3px solid rgba(59,130,246,.35); outline-offset: 2px; }

        .btn-primary {
            background-color: var(--btn-primary-bg);
            color: var(--btn-primary-text);
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .btn-primary:hover { 
            background-color: #111827; 
            box-shadow: 0 6px 16px rgba(17, 24, 39, 0.35);
            transform: translateY(-2px);
        }

        .btn-outline {
            background-color: var(--btn-outline-bg);
            border-color: var(--btn-outline-border);
            color: var(--btn-outline-text);
        }
        .btn-outline:hover {
            background-color: #e5e7eb;
            border-color: #6b7280;
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
            transform: translateY(-2px);
        }

        .btn-exercise {
            background-color: #ffffff;
            border-color: var(--btn-exercise-border);
            color: var(--btn-exercise-text);
        }
        .btn-exercise:hover {
            background-color: #ddd6fe;
            border-color: #7c3aed;
            box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);
            transform: translateY(-2px);
        }

        .btn-success {
            background-color: var(--btn-success-bg);
            color: white;
            box-shadow: 0 1px 2px rgba(0,0,0,0.08);
        }
        .btn-success:hover { 
            background-color: #065f46; 
            box-shadow: 0 6px 16px rgba(4, 120, 87, 0.4);
            transform: translateY(-2px);
        }

        .btn-danger-soft { 
            background-color: #fff1f2; 
            color: #991b1b; 
            border: 1px solid #fee2e2; 
            padding: 4px 10px; 
            font-size: 11px; 
            cursor: pointer; 
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        .btn-danger-soft:hover {
            background-color: #fecaca;
            border-color: #f87171;
            box-shadow: 0 3px 10px rgba(239, 68, 68, 0.25);
        }

        .btn-new-analysis {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(249, 115, 22, 0.35);
            position: relative;
            overflow: hidden;
        }
        .btn-new-analysis::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        .btn-new-analysis:hover {
            background: linear-gradient(135deg, #ea580c 0%, #c2410c 100%);
            box-shadow: 0 6px 20px rgba(249, 115, 22, 0.5);
            transform: translateY(-2px);
        }
        .btn-new-analysis:hover::before {
            left: 100%;
        }

        .btn-icon {
            padding: 10px 12px;
            min-width: 42px;
        }
        .btn-icon:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .btn-separator {
            width: 1px;
            height: 24px;
            background-color: #d1d5db;
            margin: 0 4px;
            align-self: center;
        }

        /* ===========================================
           ÁRBOL SINTÁCTICO
           =========================================== */
        .tree-container { 
            background: white; 
            border-radius: 8px; 
            padding: 40px; 
            border: 1px solid #e5e7eb; 
            overflow-x: auto; 
            min-height: 450px;
            position: relative; 
        }
        /* Autosave indicator (as in Kilmer) */
        .autosave-indicator{
            position: absolute;
            top: 14px;
            left: 14px;
            z-index: 40;
            background: rgba(255,255,255,0.95);
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 13px;
            color: #374151;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.25s ease, transform 0.25s ease;
            pointer-events: none;
        }
        .autosave-indicator.visible{
            opacity: 1;
            transform: translateY(0);
        }
        .autosave-dot{
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: #10b981;
            display: inline-block;
        }
        .autosave-dot.saving{
            background: #f59e0b;
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse{
            0%,100%{ transform: scale(1); opacity: .7; }
            
        .autosave-text{ display:inline-flex; align-items:center; gap:0; }
        .autosave-ellipsis{
            display: inline-flex;
            margin-left: 2px;
            letter-spacing: 1px;
        }
        .autosave-ellipsis span{
            display: inline-block;
            width: 6px;
            text-align: center;
            opacity: 0.2;
            transform: translateY(0);
            animation: ellipsis 1s infinite;
        }
        .autosave-ellipsis span:nth-child(2){ animation-delay: 0.15s; }
        .autosave-ellipsis span:nth-child(3){ animation-delay: 0.30s; }

        @keyframes ellipsis{
            0%, 60%, 100% { opacity: 0.2; transform: translateY(0); }
            30% { opacity: 1; transform: translateY(-1px); }
        }
50%{ transform: scale(1.35); opacity: 1; }
        }


        .tree-wrapper { 
            display: flex; 
            justify-content: flex-start; 
            padding: 20px 0; 
            position: relative; 
            width: fit-content; 
            min-width: 100%; 
            margin: 0 auto; 
        }

        .children-container { 
            display: flex; 
            justify-content: center; 
            align-items: flex-start; 
            position: relative; 
        }

        .child-branch { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            position: relative; 
            padding-top: 24px; 
        }

        .child-branch::before, 
        .child-branch::after { 
            content: ""; 
            position: absolute; 
            top: 0; 
            width: 50%; 
            height: 24px; 
            border-top: 1.5px solid #6b7280; 
        }
        .child-branch::before { right: 50%; }
        .child-branch::after { left: 50%; }
        .child-branch:first-child::before { border-top: none; }
        .child-branch:last-child::after { border-top: none; }

        .v-line-stem { 
            width: 1.5px; 
            height: 24px; 
            background-color: #6b7280; 
            position: absolute; 
            top: 0; 
            left: 50%; 
            transform: translateX(-50%); 
        }

        /* Modo técnico (arbóreo) */
        .technical-mode .child-branch::before, 
        .technical-mode .child-branch::after { display: none !important; }
        .technical-mode .child-branch { padding-top: 60px; }

        /* ===========================================
           NODOS
           =========================================== */
        .node-container { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            position: relative; 
            z-index: 2; 
            margin: 0 10px; 
            width: fit-content; 
        }

        .connector-v { 
            width: 1.5px; 
            background-color: #6b7280; 
            margin: 0 auto; 
        }

        .node-box { 
            padding: 12px 24px; 
            border: 1.5px solid #4b5563; 
            border-radius: 4px; 
            background-color: white; 
            font-size: 16px; 
            color: #111827; 
            min-width: 100px; 
            text-align: center; 
            position: relative; 
        }

        .node-box.can-divide { 
            border-color: #374151; 
            background-color: #f0f7ff; 
            cursor: pointer; 
        }

        .nucleus-node > .label-wrap .label-input,
        .nucleus-node > .label-wrap .label-display,
        .nucleus-node .node-box,
        .nucleus-node > div > .label-wrap .label-input,
        .nucleus-node > div > .label-wrap .label-display { 
            font-weight: bold; 
        }

        /* ===========================================
           ETIQUETAS (LABELS)
           =========================================== */
        .label-input { 
            width: 95px; 
            text-align: center; 
            border: 1px dashed #d1d5db; 
            border-radius: 4px; 
            padding: calc(4px * var(--ent-text-scale, 1)); 
            font-size: calc(11px * var(--ent-text-scale, 1)); 
            background: transparent; 
            color: #4b5563; 
            font-family: Arial, sans-serif; 
        }

        .label-input.has-value-top, 
        .label-input.has-value-bottom { 
            background-color: #f1f5f9; 
            border: 1px solid #cbd5e1; 
            color: #334155; 
        }

        .label-input.label-top { text-transform: uppercase; }

        .label-display {
            min-width: 95px;
            text-align: center;
            border: 1px dashed #d1d5db;
            border-radius: 4px;
            padding: calc(4px * var(--ent-text-scale, 1));
            font-size: calc(11px * var(--ent-text-scale, 1));
            background: transparent;
            color: #4b5563;
            font-family: Arial, sans-serif;
            cursor: text;
            display: inline-block;
        }

        .label-display.has-value {
            background-color: #f1f5f9;
            border: 1px solid #cbd5e1;
            color: #334155;
        }

        .label-display.label-top {
            text-transform: uppercase;
        }

        .label-display:hover {
            border-color: #93c5fd;
        }

        .label-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        .split-toggle-btn {
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #6b7280;
            font-size: 11px;
            line-height: 14px;
            padding: 0;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
        }

        .label-wrap:hover .split-toggle-btn {
            opacity: 1;
            pointer-events: auto;
        }

        .split-toggle-btn:hover {
            color: #374151;
            border-color: #93c5fd;
        }

        /* ===========================================
           SELECTOR DE ETIQUETAS GTG (RAE)
           =========================================== */
        .label-with-dropdown {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .dropdown-trigger {
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #c7d2fe;
            background: #eef2ff;
            color: #6366f1;
            font-size: 9px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        .label-with-dropdown:hover .dropdown-trigger {
            opacity: 1;
            pointer-events: auto;
        }

        .dropdown-trigger:hover {
            background: #c7d2fe;
            border-color: #818cf8;
            color: #4338ca;
        }

        .dropdown-trigger:active {
            background: #a5b4fc;
        }

        .label-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1000;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            min-width: 240px;
            max-height: 320px;
            overflow-y: auto;
            margin-top: 4px;
        }

        .dropdown-section {
            padding: 4px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .dropdown-section:last-child {
            border-bottom: none;
        }

        .dropdown-section-title {
            padding: 4px 12px;
            font-size: 9px;
            font-weight: 700;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: #f9fafb;
        }

        .dropdown-item {
            padding: 5px 12px;
            font-size: 11px;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.1s ease;
        }

        .dropdown-item:hover {
            background: #f0f7ff;
        }

        .dropdown-item-abbr {
            font-weight: 600;
            min-width: 50px;
            color: #1f2937;
        }

        .dropdown-item-full {
            color: #6b7280;
            font-size: 10px;
        }

        .dropdown-search {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }

        .dropdown-search input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 11px;
            outline: none;
        }

        .dropdown-search input:focus {
            border-color: #93c5fd;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }

        .dropdown-empty {
            padding: 12px;
            color: #9ca3af;
            font-size: 11px;
            text-align: center;
        }

        /* ===========================================
           BOTONES DE ACCIÓN EN NODOS
           =========================================== */
        .clear-text-btn { 
            position: absolute; 
            top: -10px; 
            right: -10px; 
            background: #ef4444; 
            color: white; 
            border: none; 
            border-radius: 50%; 
            width: 18px; 
            height: 18px; 
            font-size: 10px; 
            cursor: pointer; 
            display: none; 
            align-items: center; 
            justify-content: center; 
        }
        .node-box:hover .clear-text-btn { display: flex; }

        .add-node-btn {
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 12px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .node-box:hover .add-node-btn { display: flex; }

        .consolidate-btn {
            position: absolute;
            top: -10px;
            left: -10px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 10px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .node-box:hover .consolidate-btn { display: flex; }

        .nucleus-toggle-btn {
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            background: #ffffff;
            color: #6b7280;
            font-size: 11px;
            font-weight: bold;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            align-items: center;
            justify-content: center;
            display: flex;
            transition: opacity 0.15s ease;
        }
        .node-box:hover .nucleus-toggle-btn { 
            opacity: 1; 
            pointer-events: auto; 
        }
        .nucleus-toggle-btn:hover {
            color: #374151;
            border-color: #93c5fd;
            background: #f0f9ff;
            opacity: 1;
            pointer-events: auto;
        }
        .nucleus-toggle-btn.is-nucleus {
            background: #374151;
            color: white;
            border-color: #374151;
        }
        .nucleus-toggle-btn.is-nucleus:hover {
            background: #1f2937;
        }

        
        /* --- Botón ↩ (revertir división) sin empujar el nodo --- */
        .node-box-row{
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .node-revert-btn{
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translate(2px, -50%);
            z-index: 50;
            pointer-events: auto;
        }

/* ===========================================
           ACCIONES INFERIORES E INSTRUCCIONES
           =========================================== */
        .bottom-actions { 
            display: flex; 
            justify-content: center; 
            gap: 16px; 
            margin-top: 24px; 
            padding: 20px; 
            background: #f9fafb; 
            border-radius: 8px; 
            border: 1px solid #e5e7eb; 
            flex-wrap: wrap; 
        }

        /* ===========================================
           PANEL DE INSTRUCCIONES (ESTILO TARJETAS)
           =========================================== */
        .instructions-panel {
            margin-top: 32px;
            background: linear-gradient(135deg, #fdfcfb 0%, #f7f6f3 100%);
            border: 1px solid #e5e7eb;
            border-radius: 16px;
            overflow: hidden;
        }

        .instructions-header {
            background: #374151;
            color: white;
            padding: 16px 24px;
            font-size: 1.15rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background-color 0.2s ease;
        }

        .instructions-header:hover {
            background: #4b5563;
        }

        .instructions-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .instructions-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .instructions-content {
            max-height: 4000px;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .instructions-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1px;
            background: #e5e7eb;
        }

        @media (max-width: 600px) {
            .instructions-grid {
                grid-template-columns: 1fr;
            }
        }

        .instruction-card {
            background: white;
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .instruction-card h4 {
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }

        .instruction-card h4 .icon {
            width: 24px;
            height: 24px;
            background: #374151;
            color: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .instruction-card ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 13px;
            line-height: 1.6;
            color: #6b7280;
        }

        .instruction-card li {
            position: relative;
            padding-left: 16px;
            margin-bottom: 6px;
        }

        .instruction-card li::before {
            content: "•";
            position: absolute;
            left: 0;
            color: #374151;
            font-weight: bold;
        }

        .instruction-card li:last-child {
            margin-bottom: 0;
        }

        .instruction-card strong {
            color: #374151;
        }

        .instruction-card code {
            display: inline-block;
            background: #f5f4f0;
            padding: 1px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Consolas, monospace;
            font-size: 12px;
            color: #374151;
            border: 1px solid #e8e6e1;
        }

        /* --- Estilo de Tecla Física --- */
        .key {
            display: inline-block;
            background: linear-gradient(180deg, #fafafa 0%, #e8e8e8 100%);
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-family: system-ui, sans-serif;
            font-weight: 600;
            color: #374151;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            margin: 0 2px;
        }

        /* --- Limpieza de Listas de Atajos --- */
        .shortcut-list li::before {
            content: none !important;
        }

        .shortcut-list li {
            padding-left: 0 !important;
            margin-bottom: 8px !important;
            color: #4b5563;
        }

        /* ===========================================
           MODO EJERCITACIÓN
           =========================================== */
        .exercise-banner {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-left: 6px solid #8b5cf6;
            color: #111827;
            padding: 16px 24px;
            border-radius: 10px;
            margin-bottom: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .exercise-banner-text {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .exercise-banner-icon { font-size: 20px; }
        .exercise-banner h3 { margin: 0; font-size: 16px; color: #111827; }
        .exercise-banner p { margin: 4px 0 0; font-size: 13px; color: #6b7280; }

        .exercise-banner {
            display: flex;
            flex-direction: column; /* Apila el título arriba y los botones abajo */
            align-items: center;    /* Centra todo horizontalmente */
            text-align: center;     /* Asegura que el texto interno esté centrado */
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-top: 4px solid #8b5cf6;
            border-bottom: 4px solid #8b5cf6;
            padding: 24px;
            border-radius: 8px;
            margin-bottom: 24px;
            gap: 20px;
        }

        /* ===========================================
           COMPARACIÓN DE RESULTADOS
           =========================================== */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-top: 24px;
        }

        .comparison-panel {
            background: white;
            border-radius: 8px;
            padding: 24px;
            border: 2px solid #e5e7eb;
            overflow-x: auto;
        }
        .comparison-panel.student { border-color: #3b82f6; }
        .comparison-panel.model { border-color: #10b981; }

        .comparison-panel h3 {
            margin: 0 0 16px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .comparison-panel.student h3 { color: #3b82f6; }
        .comparison-panel.model h3 { color: #10b981; }

        .comparison-tree { overflow-x: auto; }

        /* Resaltado de diferencias */
        .node-correct .node-box {
            border-color: #10b981 !important;
            background-color: #ecfdf5 !important;
        }
        .node-incorrect .node-box {
            border-color: #ef4444 !important;
            background-color: #fef2f2 !important;
        }
        .label-correct {
            background-color: #d1fae5 !important;
            border-color: #10b981 !important;
            color: #065f46 !important;
        }
        .label-incorrect {
            background-color: #fee2e2 !important;
            border-color: #ef4444 !important;
            color: #991b1b !important;
        }

        /* Resumen de resultados */
        .results-summary {
            background: white;
            border-radius: 8px;
            padding: 24px;
            margin-bottom: 24px;
            border: 1px solid #e5e7eb;
        }
        .results-summary h3 { margin: 0 0 16px; color: #374151; }

        .results-stats {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .stat-dot.correct { background-color: #10b981; }
        .stat-dot.incorrect { background-color: #ef4444; }
        .stat-dot.partial { background-color: #f59e0b; }

        /* ===========================================
           MODAL SELECTOR DE POSICIÓN
           =========================================== */
        .pos-overlay {
            position: fixed;
            inset: 0;
            background: rgba(17,24,39,.35);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .pos-modal {
            width: min(520px, calc(100vw - 32px));
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,.18);
            padding: 18px 18px 14px;
        }

        .pos-title {
            font-weight: 700;
            color: #111827;
            margin: 0 0 6px;
        }

        .pos-sub {
            margin: 0 0 12px;
            color: #6b7280;
            font-size: 13px;
            line-height: 1.35;
        }

        .pos-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .pos-select {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            background: #fff;
            color: #111827;
        }

        .pos-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 14px;
        }

        /* ===========================================
           MODAL DE ARCHIVOS
           =========================================== */
        .files-modal {
            width: min(600px, calc(100vw - 32px));
            max-height: calc(100vh - 64px);
            background: #fff;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,.18);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .files-modal-header {
            padding: 18px 20px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .files-modal-title {
            font-weight: 700;
            color: #111827;
            margin: 0 0 16px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .files-tabs {
            display: flex;
            gap: 0;
        }

        .files-tab {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .files-tab:hover {
            color: #374151;
            background: #f9fafb;
        }

        .files-tab.active {
            color: #374151;
            border-bottom-color: #374151;
        }

        .files-modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .files-section {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .files-section-title {
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .files-btn-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .files-btn-row .btn {
            flex: 1;
            min-width: 140px;
            justify-content: center;
        }

        /* Banco de ejemplos */
        .drive-connect-row {
            display: flex;
            gap: 10px;
            align-items: stretch;
        }

        .drive-url-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        .drive-url-input:focus {
            border-color: #93c5fd;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .drive-url-input::placeholder {
            color: #9ca3af;
        }

        .drive-status {
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .drive-status.loading {
            background: #f0f9ff;
            color: #0369a1;
            border: 1px solid #bae6fd;
        }

        .drive-status.error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .drive-status.success {
            background: #f0fdf4;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .drive-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #bae6fd;
            border-top-color: #0369a1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .drive-files-list {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            max-height: 300px;
            overflow-y: auto;
        }

        .drive-folder {
            border-bottom: 1px solid #e5e7eb;
        }

        .drive-folder:last-child {
            border-bottom: none;
        }

        .drive-folder-header {
            padding: 10px 14px;
            background: #f9fafb;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s ease;
        }

        .drive-folder-header:hover {
            background: #f3f4f6;
        }

        .drive-folder-toggle {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .drive-folder-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .drive-folder-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .drive-folder-content.collapsed {
            max-height: 0;
        }

        .drive-file-item {
            padding: 10px 14px 10px 28px;
            font-size: 13px;
            color: #374151;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.15s ease;
        }

        .drive-file-item:last-child {
            border-bottom: none;
        }

        .drive-file-item:hover {
            background: #f0f7ff;
        }

        .drive-file-item.selected {
            background: #eff6ff;
            border-left: 3px solid #3b82f6;
            padding-left: 25px;
        }

        .drive-file-icon {
            font-size: 14px;
        }

        .drive-file-name {
            flex: 1;
        }

        /* Opciones de carga */
        .drive-load-options {
            padding: 16px;
            background: #f9fafb;
            border-top: 1px solid #e5e7eb;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .drive-load-options .btn {
            min-width: 160px;
        }

        .files-modal-footer {
            padding: 14px 20px;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: flex-end;
        }

        .drive-root-files {
            padding: 4px 0;
        }

        .files-help-text {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
            line-height: 1.5;
        }

        .files-help-text code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        /* ===========================================
           PIE DE PÁGINA
           =========================================== */
        .footer {
            margin-top: 40px;
            padding: 20px 0;
            text-align: center;
            border-top: 1px solid #e5e7eb;
            color: #6b7280;
            font-size: 14px;
        }
        .footer strong { color: #374151; }
        .footer a { color: #374151; text-decoration: none; }
        .footer a:hover { text-decoration: underline; }
        .footer img { 
            opacity: 0.8; 
            transition: opacity 0.2s;
            display: block;
            margin: 10px auto 0;
            height: 31px; 
            width: auto;
        }
        .footer img:hover { opacity: 1; }

        .analyze-undo-group {
            display: contents;
        }    
    

        /* ===========================================
           RESPONSIVE - TABLETS Y MÓVILES
           =========================================== */
        @media (max-width: 768px) {
            .container { padding: 12px 16px 24px; }
            
            .header-logo { max-width: 300px; }
            
            .input-section { padding: 16px; }
            
            .input-row { 
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }

            .input-row input[type="text"] {
                grid-column: 1 / -1;
            }

            .input-row > button:last-of-type {
                grid-column: 1 / -1;
            }
            
            .btn {
                padding: 12px 16px;
                justify-content: center;
            }
            
            .language-selector {
                position: static;
                justify-content: center;
                margin-bottom: 12px;
            }

            .language-selector .language-flag {
                height: 24px;
            }

            .tree-display-container {
                padding: 16px;
            }
            
            .node-label-container {
                min-width: 80px;
            }
            
            .node-actions button {
                padding: 4px;
                font-size: 11px;
            }
            
            .comparison-panels {
                flex-direction: column;
            }
            
            .results-stats {
                flex-direction: column;
                gap: 12px;
            }
            
            .pos-modal {
                padding: 14px;
            }
            
            .pos-row {
                flex-direction: column;
            }
            
            .pos-select {
                width: 100%;
            }

            .btn-separator {
                display: none;
            }

            .analyze-undo-group {
                display: grid;
                grid-template-columns: 2fr 1fr 1fr;
                gap: 8px;
                grid-column: 1 / -1;
            }
        }
        
        @media (max-width: 480px) {
            .header-logo { max-width: 220px; }
            
            .btn {
                font-size: 13px;
                padding: 10px 12px;
            }
            
            .node-label-container {
                min-width: 60px;
                font-size: 10px;
            }
            
            .node-actions {
                gap: 2px;
            }
            
            .node-actions button {
                padding: 3px;
                font-size: 10px;
            }
            
            .results-summary {
                padding: 16px;
            }
        }

        /* ===========================================
           CONTROLES DE ZOOM
           =========================================== */
        .zoom-controls-wrapper {
            position: sticky;
            top: 0;
            left: 0;
            width: 100%;
            height: 0;
            z-index: 100;
            pointer-events: none;
        }
        .zoom-controls {
            position: absolute;
            top: -30px;
            right: -30px;
            display: flex;
            align-items: center;
            gap: 2px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #d1d5db;
            border-radius: 8px;
            padding: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        .zoom-controls.visible {
            opacity: 0.6;
            pointer-events: auto;
        }
        .zoom-controls.visible:hover {
            opacity: 1;
        }
        .zoom-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            border-radius: 4px;
            transition: background 0.15s;
        }
        .zoom-btn:hover:not(:disabled) {
            background: rgba(0,0,0,0.08);
        }
        .zoom-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .zoom-indicator {
            min-width: 44px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.15s, color 0.15s;
            user-select: none;
        }
        .zoom-indicator:hover {
            background: rgba(0,0,0,0.08);
            color: #374151;
        }

        /* Contenedor de zoom */
        .zoom-container {
            transform-origin: top left;
        }

        /* Ajustes para tree-container con zoom */
        .tree-container {
            position: relative;
            overflow: auto;
            max-width: 100%;
        }

        /* Ajustes para comparison-panel con zoom */
        .comparison-panel {
            position: relative;
        }
        .comparison-panel .zoom-controls-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 0;
            z-index: 120;
            pointer-events: none;
        }
        .comparison-panel .zoom-controls {
            top: 2px;
            right: 2px;
        }
        .comparison-tree {
            overflow: auto;
            min-height: 200px;
            max-height: 500px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback, useMemo } = React;

        // ===========================================
        // CATÁLOGO DE ETIQUETAS GTG (RAE)
        // Basado en el Glosario de términos gramaticales
        // ===========================================
        const GTG_LABELS = {
            // FUNCIONES SINTÁCTICAS (etiqueta superior)
            oracionesFunciones: {
                title: 'Oraciones y cláusulas',
                items: [
                    { abbr: 'TXT', full: 'texto' },
                    { abbr: 'O', full: 'oración' },
                    { abbr: 'CL', full: 'cláusula' },
                    { abbr: 'CLM', full: 'cláusula matriz' },
                    { abbr: 'CLS', full: 'cláusula subordinada' },
                    { abbr: 'CLS SUS', full: 'cláusula subordinada sustantiva' },
                    { abbr: 'CLS ADJ', full: 'cláusula subordinada adjetiva' },
                    { abbr: 'CLS ADV', full: 'cláusula subordinada adverbial' },
                    { abbr: 'COORD', full: 'coordinación' },
                ]
            },
            funciones: {
                title: 'Funciones sintácticas',
                items: [
                    { abbr: 'SUJ', full: 'sujeto' },
                    { abbr: 'SUJ DES', full: 'sujeto desinencial' },
                    { abbr: 'SUJ TAC', full: 'sujeto tácito' },
                    { abbr: 'SUJ IND', full: 'sujeto indeterminado' },
                    { abbr: 'SUN IMP', full: 'sujeto impersonal' },
                    { abbr: 'CD', full: 'complemento directo' },
                    { abbr: 'CI', full: 'complemento indirecto' },
                    { abbr: 'C REG', full: 'complemento de régimen' },
                    { abbr: 'CC', full: 'complemento circunstancial' },
                    { abbr: 'CC T', full: 'c. circunstancial de tiempo' },
                    { abbr: 'CC LOC', full: 'c. circunstancial de lugar' },
                    { abbr: 'CC MOD', full: 'c. circunstancial de modo' },
                    { abbr: 'CC CAUS', full: 'c. circunstancial de causa' },
                    { abbr: 'CC FIN', full: 'c. circunstancial de finalidad' },
                    { abbr: 'CC INST', full: 'c. circunstancial de instrumento' },
                    { abbr: 'CC CANT', full: 'c. circunstancial de cantidad' },
                    { abbr: 'CC COMP', full: 'c. circunstancial de compañía' },
                    { abbr: 'C AG', full: 'complemento agente' },
                    { abbr: 'ATR', full: 'atributo' },
                    { abbr: 'C PVO', full: 'complemento predicativo' },
                    { abbr: 'TER', full: 'término' },
                    { abbr: 'CN', full: 'complemento del nombre' },
                    { abbr: 'C ADJ', full: 'complemento del adjetivo' },
                    { abbr: 'C ADV', full: 'complemento del adverbio' },
                    { abbr: 'CPRO', full: 'complemento del pronombre' },
                    { abbr: 'APOS', full: 'aposición' },
                    { abbr: 'VOC', full: 'vocativo' },
                ]
            },
            funcionesInternas: {
                title: 'Funciones internas',
                items: [
                    { abbr: 'NUC', full: 'núcleo' },
                    { abbr: 'MOD', full: 'modificador' },
                    { abbr: 'DET', full: 'determinante' },
                    { abbr: 'ADY', full: 'adyacente' },
                    { abbr: 'ENL', full: 'enlace' },
                    { abbr: 'NX', full: 'nexo' },
                ]
            },
            // CATEGORÍAS / CLASES DE PALABRAS (etiqueta inferior)
            sintagmas: {
                title: 'Sintagmas / Grupos',
                items: [
                    { abbr: 'FN', full: 'frase nominal' },
                    { abbr: 'FV', full: 'frase verbal' },
                    { abbr: 'FPrep', full: 'frase preposicional' },
                    { abbr: 'FAdj', full: 'frase adjetival' },
                    { abbr: 'FAdv', full: 'frase adverbial' },                    
                    { abbr: 'FInf', full: 'frase de infinitivo' },
                    { abbr: 'FGer', full: 'frase de gerundio' },
                    { abbr: 'FPart', full: 'frase participio' },
                    { abbr: 'FPro', full: 'frase pronominal' },
                ]
            },
            palabras: {
                title: 'Clases de palabras',
                items: [
                    { abbr: 'v', full: 'verbo' },
                    { abbr: 'perif verb', full: 'perífrasis verbal' },
                    { abbr: 'sust', full: 'sustantivo común' },
                    { abbr: 'np', full: 'nombre propio' },
                    { abbr: 'prep', full: 'preposición' },
                    { abbr: 'adj cal', full: 'adjetivo calificativo' },
                    { abbr: 'adj rel', full: 'adjetivo relacional' },
                    { abbr: 'det', full: 'determinante' },
                    { abbr: 'pron', full: 'pronombre' },                  
                    { abbr: 'adv', full: 'adverbio' },
                    { abbr: 'adv t', full: 'adverbio de tiempo' },
                    { abbr: 'adv loc', full: 'adverbio de lugar' },
                    { abbr: 'adv mod', full: 'adverbio de modo' },
                    { abbr: 'adv cant', full: 'adverbio de cantidad' },
                    { abbr: 'adv af', full: 'adverbio de afirmación' },
                    { abbr: 'adv neg', full: 'adverbio de negación' },
                    { abbr: 'adv dud', full: 'adverbio de duda' },
                    { abbr: 'conj', full: 'conjunción' },
                    { abbr: 'conj cop', full: 'conjunción copulativa' },
                    { abbr: 'conj disy', full: 'conjunción disyuntiva' },
                    { abbr: 'conj adv', full: 'conjunción adverbial' },
                    { abbr: 'interj', full: 'interjección' },
                    { abbr: 'clit', full: 'clítico' },
                    { abbr: 'clit acus', full: 'clítico acusativo' },
                    { abbr: 'clit dat', full: 'clítico dativo' },
                    { abbr: 'clit refl', full: 'clítico reflexivo' },
                    { abbr: 'loc verb', full: 'locución verbal' },
                    { abbr: 'loc nom', full: 'locución nominal' },
                    { abbr: 'loc prep', full: 'locución preposicional' },
                    { abbr: 'loc adj', full: 'locución adjetival' },
                    { abbr: 'loc adv', full: 'locución adverbial' },
                    { abbr: 'loc conj', full: 'locución conjuntiva' },
                    { abbr: 'inf', full: 'infinitivo' },
                    { abbr: 'ger', full: 'gerundio' },
                    { abbr: 'part', full: 'participio' },
                ]
            },
            determinantes: {
                title: 'Tipos de determinantes',
                items: [
                    { abbr: 'art det', full: 'artículo determinado' },
                    { abbr: 'art ind', full: 'artículo indeterminado' },
                    { abbr: 'dem', full: 'demostrativo' },
                    { abbr: 'pos', full: 'posesivo' },
                    { abbr: 'cuant', full: 'cuantificador' },
                    { abbr: 'num', full: 'numeral' },
                    { abbr: 'indef', full: 'indefinido' },
                    { abbr: 'interr', full: 'interrogativo' },
                    { abbr: 'excl', full: 'exclamativo' },
                    { abbr: 'rel', full: 'relativo' },
                ]
            },
            pronombres: {
                title: 'Tipos de pronombres',
                items: [
                    { abbr: 'pron pers', full: 'pronombre personal' },
                    { abbr: 'pron dem', full: 'pronombre demostrativo' },
                    { abbr: 'pron pos', full: 'pronombre posesivo' },
                    { abbr: 'pron indef', full: 'pronombre indefinido' },
                    { abbr: 'pron interr', full: 'pronombre interrogativo' },
                    { abbr: 'pron rel', full: 'pronombre relativo' },
                    { abbr: 'pron excl', full: 'pronombre exclamativo' },
                ]
            },
            oracionesCat: {
                title: 'Oraciones y cláusulas',
                items: [
                    { abbr: 'TXT', full: 'texto' },
                    { abbr: 'O', full: 'oración' },
                    { abbr: 'CL', full: 'cláusula' },
                    { abbr: 'CLM', full: 'cláusula matriz' },
                    { abbr: 'CLS', full: 'cláusula subordinada' },
                    { abbr: 'CLS SUS', full: 'cláusula subordinada sustantiva' },
                    { abbr: 'CLS ADJ', full: 'cláusula subordinada adjetiva' },
                    { abbr: 'CLS ADV', full: 'cláusula subordinada adverbial' },
                    { abbr: 'COORD', full: 'coordinación' },
                ]
            }
        };

        // Secciones para etiqueta superior (funciones)
        const FUNC_SECTIONS = ['oracionesFunciones', 'funciones', 'funcionesInternas'];
        
        // Secciones para etiqueta inferior (categorías)
        const CAT_SECTIONS = ['sintagmas', 'palabras', 'determinantes', 'pronombres', 'oracionesCat'];

        const SyntaxTreeBuilder = () => {
            // ===========================================
            // ESTADO
            // ===========================================
            const [sentence, setSentence] = useState('');
            const [tree, setTree] = useState(null);
            const [divisionMode, setDivisionMode] = useState(null);
            const [selectedCuts, setSelectedCuts] = useState([]);
            const [posPicker, setPosPicker] = useState(null);

            // Modo ejercicio
            const [exerciseMode, setExerciseMode] = useState(false);
            const [modelTree, setModelTree] = useState(null);
            const [showComparison, setShowComparison] = useState(false);
            const [comparisonResults, setComparisonResults] = useState(null);

            // Historial Undo/Redo
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const isUndoRedo = useRef(false);

            // Panel de instrucciones
            const [instructionsCollapsed, setInstructionsCollapsed] = useState(true);

            // Modal de archivos
            const [showFilesModal, setShowFilesModal] = useState(false);
            const [filesActiveTab, setFilesActiveTab] = useState('local');
            const [driveUrl, setDriveUrl] = useState(() => localStorage.getItem('ent_drive_url') || '');
            const [driveStatus, setDriveStatus] = useState({ type: null, message: '' });
            const [driveFiles, setDriveFiles] = useState([]);
            const [selectedDriveFile, setSelectedDriveFile] = useState(null);
            const [collapsedFolders, setCollapsedFolders] = useState({});

            // Referencias
            const fileInputRef = useRef(null);
            const exerciseInputRef = useRef(null);
            const treeContainerRef = useRef(null);
            const zoomContainerRef = useRef(null);
            const studentZoomContainerRef = useRef(null);
            const modelZoomContainerRef = useRef(null);

            // Estado de zoom (para las 3 vistas)
            const [zoomLevel, setZoomLevel] = useState(100);
            const [studentZoomLevel, setStudentZoomLevel] = useState(100);
            const [modelZoomLevel, setModelZoomLevel] = useState(100);

            // Auto-guardado
            const [isSaving, setIsSaving] = useState(false);
            const [lastSaved, setLastSaved] = useState(null);
            const formatTimeAgo = (dateObj) => {
                if (!dateObj) return '';
                const diffMs = Date.now() - dateObj.getTime();
                const diffSec = Math.max(0, Math.floor(diffMs / 1000));
                if (diffSec < 10) return 'recién';
                if (diffSec < 60) return 'hace unos segundos';
                const diffMin = Math.floor(diffSec / 60);
                if (diffMin < 60) return `hace ${diffMin} min`;
                const diffHr = Math.floor(diffMin / 60);
                if (diffHr < 24) return `hace ${diffHr} h`;
                const diffDay = Math.floor(diffHr / 24);
                return `hace ${diffDay} día${diffDay === 1 ? '' : 's'}`;
            };



            // Escala tipográfica extra (curva suave) para evitar amontonamiento en zoom mínimo
            const textScale = useMemo(() => {
                const z = zoomLevel / 100;
                // Curva tipográfica solo para zooms < 100% (evita amontonamiento en mínimos sin "inflar" en máximos)
                if (z >= 1) return 1;
                // escala extra => tamaño efectivo ~= z^(1.24)
                return Math.pow(z, 0.24);
            }, [zoomLevel]);

            const studentTextScale = useMemo(() => {
                const z = studentZoomLevel / 100;
                if (z >= 1) return 1;
                return Math.pow(z, 0.24);
            }, [studentZoomLevel]);

            const modelTextScale = useMemo(() => {
                const z = modelZoomLevel / 100;
                if (z >= 1) return 1;
                return Math.pow(z, 0.24);
            }, [modelZoomLevel]);

            // Constantes de zoom
            const ZOOM_MIN = 40;
            const ZOOM_MAX = 200;
            const ZOOM_STEP = 20;

            // Funciones de zoom para vista principal
            const zoomIn = useCallback(() => {
                setZoomLevel(prev => Math.min(prev + ZOOM_STEP, ZOOM_MAX));
            }, []);

            const zoomOut = useCallback(() => {
                setZoomLevel(prev => Math.max(prev - ZOOM_STEP, ZOOM_MIN));
            }, []);

            const zoomReset = useCallback(() => {
                setZoomLevel(100);
            }, []);

            // Funciones de zoom para panel estudiante (comparación)
            const studentZoomIn = useCallback(() => {
                setStudentZoomLevel(prev => Math.min(prev + ZOOM_STEP, ZOOM_MAX));
            }, []);

            const studentZoomOut = useCallback(() => {
                setStudentZoomLevel(prev => Math.max(prev - ZOOM_STEP, ZOOM_MIN));
            }, []);

            const studentZoomReset = useCallback(() => {
                setStudentZoomLevel(100);
            }, []);

            // Funciones de zoom para panel modelo (comparación)
            const modelZoomIn = useCallback(() => {
                setModelZoomLevel(prev => Math.min(prev + ZOOM_STEP, ZOOM_MAX));
            }, []);

            const modelZoomOut = useCallback(() => {
                setModelZoomLevel(prev => Math.max(prev - ZOOM_STEP, ZOOM_MIN));
            }, []);

            const modelZoomReset = useCallback(() => {
                setModelZoomLevel(100);
            }, []);

            // ===========================================
            // UTILIDADES
            // ===========================================
            const getFileName = (extension) => {
                const words = sentence.trim().split(/\s+/).slice(0, 5).join('_');
                // Usar .ent como extensión por defecto para JSON
                const ext = extension === 'json' ? 'ent' : extension;
                return `${words}.${ext}`;
            };

            const normalizeSentence = (text) => {
                return text.trim()
                    .replace(/\bdel\b/gi, 'de el')
                    .replace(/\bal\b/gi, 'a el')
                    .replace(/\bconmigo\b/gi, 'con migo')
                    .replace(/\bcontigo\b/gi, 'con tigo')
                    .replace(/\bconsigo\b/gi, 'con sigo');
            };

            const createEmptyTree = (text) => ({
                id: 'root',
                text: normalizeSentence(text),
                labelTop: '',
                labelBottom: '',
                children: null,
                isNucleus: false,
                isConsolidated: false
            });

            const makeNewNode = (text = '') => ({
                id: `added-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                text,
                labelTop: '',
                labelBottom: '',
                children: null,
                isNucleus: false,
                isInserted: true,
                isConsolidated: false
            });

            const updateNode = (node, id, updates) => {
                if (node.id === id) return { ...node, ...updates };
                if (node.children) {
                    return { ...node, children: node.children.map(c => updateNode(c, id, updates)) };
                }
                return node;
            };

            const findNodeById = (n, id) => {
                if (!n) return null;
                if (n.id === id) return n;
                if (n.children) {
                    for (const c of n.children) {
                        const r = findNodeById(c, id);
                        if (r) return r;
                    }
                }
                return null;
            };

            const shorten = (s, n = 18) => {
                const t = (s || '').trim();
                if (!t) return '∅';
                return t.length > n ? t.slice(0, n - 1) + '…' : t;
            };

            const buildPosLabel = (i, siblings) => {
                const n = siblings.length;
                if (i === 1) return 'Al inicio';
                if (i === n + 1) return 'Al final';
                const left = shorten(siblings[i - 2]);
                const right = shorten(siblings[i - 1]);
                return `Entre "${left}" y "${right}"`;
            };

            // ===========================================
            // FORMATO DE TEXTO EN ETIQUETAS
            // ===========================================
            const formatLabelText = (text) => {
                if (!text) return null;
                
                const parts = [];
                let remaining = text;
                let key = 0;
                
                const patterns = [
                    { regex: /\*\*([^*]+)\*\*/, style: { fontWeight: 'bold' } },
                    { regex: /\*([^*]+)\*/, style: { fontStyle: 'italic' } },
                    { regex: /_([^_]+)_/, style: { fontSize: '0.75em', verticalAlign: 'sub' } },
                    { regex: /¨([^¨]+)¨/, style: { fontSize: '0.75em', verticalAlign: 'super' } }
                ];
                
                while (remaining.length > 0) {
                    let earliestMatch = null;
                    let earliestIndex = remaining.length;
                    let matchedPattern = null;
                    
                    for (const pattern of patterns) {
                        const match = remaining.match(pattern.regex);
                        if (match && match.index < earliestIndex) {
                            earliestMatch = match;
                            earliestIndex = match.index;
                            matchedPattern = pattern;
                        }
                    }
                    
                    if (earliestMatch && matchedPattern) {
                        if (earliestIndex > 0) {
                            parts.push(<span key={key++}>{remaining.substring(0, earliestIndex)}</span>);
                        }
                        parts.push(
                            <span key={key++} style={matchedPattern.style}>
                                {earliestMatch[1]}
                            </span>
                        );
                        remaining = remaining.substring(earliestIndex + earliestMatch[0].length);
                    } else {
                        parts.push(<span key={key++}>{remaining}</span>);
                        break;
                    }
                }
                
                return parts.length > 0 ? parts : text;
            };

            // Función para aplicar formato HTML en exportación (DOM)
            const applyFormatToSpan = (span, text) => {
                if (!text) {
                    span.textContent = '';
                    return;
                }
                
                span.innerHTML = '';
                let remaining = text;
                
                const patterns = [
                    { regex: /\*\*([^*]+)\*\*/, tag: 'strong', style: '' },
                    { regex: /\*([^*]+)\*/, tag: 'em', style: '' },
                    { regex: /_([^_]+)_/, tag: 'sub', style: 'font-size: 0.75em;' },
                    { regex: /¨([^¨]+)¨/, tag: 'sup', style: 'font-size: 0.75em;' }
                ];
                
                while (remaining.length > 0) {
                    let earliestMatch = null;
                    let earliestIndex = remaining.length;
                    let matchedPattern = null;
                    
                    for (const pattern of patterns) {
                        const match = remaining.match(pattern.regex);
                        if (match && match.index < earliestIndex) {
                            earliestMatch = match;
                            earliestIndex = match.index;
                            matchedPattern = pattern;
                        }
                    }
                    
                    if (earliestMatch && matchedPattern) {
                        if (earliestIndex > 0) {
                            span.appendChild(document.createTextNode(remaining.substring(0, earliestIndex)));
                        }
                        const el = document.createElement(matchedPattern.tag);
                        if (matchedPattern.style) el.style.cssText = matchedPattern.style;
                        el.textContent = earliestMatch[1];
                        span.appendChild(el);
                        remaining = remaining.substring(earliestIndex + earliestMatch[0].length);
                    } else {
                        span.appendChild(document.createTextNode(remaining));
                        break;
                    }
                }
            };

            // ===========================================
            // HISTORIAL UNDO/REDO
            // ===========================================
            useEffect(() => {
                if (tree && !isUndoRedo.current) {
                    setHistory(prev => {
                        const newHistory = prev.slice(0, historyIndex + 1);
                        newHistory.push(JSON.stringify(tree));
                        if (newHistory.length > 50) newHistory.shift();
                        return newHistory;
                    });
                    setHistoryIndex(prev => Math.min(prev + 1, 49));
                }
                isUndoRedo.current = false;
            }, [tree]);

            const canUndo = historyIndex > 0;
            const canRedo = historyIndex < history.length - 1;

            const handleUndo = useCallback(() => {
                if (canUndo) {
                    isUndoRedo.current = true;
                    setHistoryIndex(prev => prev - 1);
                    setTree(JSON.parse(history[historyIndex - 1]));
                }
            }, [canUndo, history, historyIndex]);

            const handleRedo = useCallback(() => {
                if (canRedo) {
                    isUndoRedo.current = true;
                    setHistoryIndex(prev => prev + 1);
                    setTree(JSON.parse(history[historyIndex + 1]));
                }
            }, [canRedo, history, historyIndex]);

            // ===========================================
            // GUARDAR (definido aquí para usar en atajos)
            // ===========================================
            const handleSaveJSON = useCallback(() => {
    if (!tree) return;
    const blob = new Blob([JSON.stringify({ sentence, tree }, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const words = sentence.trim().split(/\s+/).slice(0, 5).join('_');
    a.download = `${words}.ent`;
    a.click();

    // Limpiar auto-guardado después de un guardado manual
    localStorage.removeItem('ent-autosave');
    setLastSaved(null);
}, [tree, sentence]);


            // ===========================================
            // AUTO-GUARDADO (localStorage)
            // ===========================================
            const debounce = (func, delay) => {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func(...args), delay);
                };
            };

            const performAutoSave = useCallback(() => {
                if (!tree || isUndoRedo.current) return;

                setIsSaving(true);
                const data = {
                    sentence,
                    tree,
                    divisionMode,
                    selectedCuts,
                    exerciseMode,
                    modelTree,
                    timestamp: new Date().toISOString(),
                    version: '1.0'
                };

                try {
                    localStorage.setItem('ent-autosave', JSON.stringify(data));
                    setLastSaved(new Date());
                    setTimeout(() => setIsSaving(false), 500);
                } catch (err) {
                    console.error('Error auto-saving:', err);
                    setIsSaving(false);
                }
            }, [sentence, tree, divisionMode, selectedCuts, exerciseMode, modelTree]);

            const autoSaveDebounced = useRef(null);
            if (!autoSaveDebounced.current) {
                autoSaveDebounced.current = debounce((saveFn) => saveFn(), 3000);
            }

            // Auto-save: guardar cuando cambien los estados relevantes
            useEffect(() => {
                if (tree && !isUndoRedo.current) {
                    autoSaveDebounced.current(performAutoSave);
                }
            }, [sentence, tree, divisionMode, selectedCuts, exerciseMode, modelTree, performAutoSave]);

            // Restore from auto-save on mount
            useEffect(() => {
                const saved = localStorage.getItem('ent-autosave');
                if (!saved) return;

                try {
                    const data = JSON.parse(saved);
                    const savedDate = new Date(data.timestamp);
                    const minutesAgo = Math.round((Date.now() - savedDate.getTime()) / 60000);

                    const message = minutesAgo < 1
                        ? 'Se encontró trabajo no guardado.\n\n¿Quieres continuar donde lo dejaste?'
                        : `Se encontró trabajo no guardado de hace ${minutesAgo} minuto${minutesAgo === 1 ? '' : 's'}.\n\n¿Quieres continuar donde lo dejaste?`;

                    const restore = confirm(message);

                    if (restore) {
                        isUndoRedo.current = true;

                        setSentence(data.sentence || '');
                        setTree(data.tree || null);
                        setDivisionMode(data.divisionMode ?? null);
                        setSelectedCuts(Array.isArray(data.selectedCuts) ? data.selectedCuts : []);
                        setExerciseMode(!!data.exerciseMode);
                        setModelTree(data.modelTree || null);
                        setShowComparison(false);
                        setComparisonResults(null);

                        setHistory([]);
                        setHistoryIndex(-1);

                        setTimeout(() => { isUndoRedo.current = false; }, 0);
                    } else {
                        localStorage.removeItem('ent-autosave');
                        setLastSaved(null);
                    }
                } catch (err) {
                    console.error('Error restoring auto-save:', err);
                    localStorage.removeItem('ent-autosave');
                    setLastSaved(null);
                }
            }, []); // Solo al montar

            // ===========================================
            // GOOGLE DRIVE API
            // ===========================================
            const GOOGLE_API_KEY = 'AIzaSyB1XWEgGpX-SWi6GlzqXcOOk7pFc6jLCsU';

            const extractFolderId = (url) => {
                // Soportar varios formatos de URL de Google Drive
                const patterns = [
                    /\/folders\/([a-zA-Z0-9_-]+)/,
                    /id=([a-zA-Z0-9_-]+)/,
                    /^([a-zA-Z0-9_-]+)$/
                ];
                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match) return match[1];
                }
                return null;
            };

            const fetchDriveFolder = async (folderId, folderName = 'Raíz') => {
                const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&key=${GOOGLE_API_KEY}&fields=files(id,name,mimeType)&orderBy=name`;
                const response = await fetch(url);
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'Error al acceder a la carpeta');
                }
                const data = await response.json();
                return { folderId, folderName, files: data.files || [] };
            };

            const organizeFiles = async (rootFolderId) => {
                const result = [];
                const rootData = await fetchDriveFolder(rootFolderId, 'Raíz');
                
                // Separar archivos .ent y subcarpetas
                const entFiles = rootData.files.filter(f => f.name.endsWith('.ent'));
                const folders = rootData.files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
                
                // Agregar archivos de la raíz
                if (entFiles.length > 0) {
                    result.push({ folderName: null, files: entFiles });
                }
                
                // Procesar subcarpetas
                for (const folder of folders) {
                    try {
                        const folderData = await fetchDriveFolder(folder.id, folder.name);
                        const folderEntFiles = folderData.files.filter(f => f.name.endsWith('.ent'));
                        if (folderEntFiles.length > 0) {
                            result.push({ folderName: folder.name, folderId: folder.id, files: folderEntFiles });
                        }
                    } catch (e) {
                        console.warn(`No se pudo acceder a la carpeta ${folder.name}:`, e);
                    }
                }
                
                return result;
            };

            const handleConnectDrive = async () => {
                const folderId = extractFolderId(driveUrl.trim());
                if (!folderId) {
                    setDriveStatus({ type: 'error', message: 'URL no válida. Ingresa una URL de carpeta de Google Drive.' });
                    return;
                }

                // Guardar la URL en localStorage
                localStorage.setItem('ent_drive_url', driveUrl.trim());
                
                setDriveStatus({ type: 'loading', message: 'Conectando con Google Drive...' });
                setDriveFiles([]);
                setSelectedDriveFile(null);

                try {
                    const files = await organizeFiles(folderId);
                    if (files.length === 0 || files.every(f => f.files.length === 0)) {
                        setDriveStatus({ type: 'error', message: 'No se encontraron archivos .ent en esta carpeta.' });
                        return;
                    }
                    setDriveFiles(files);
                    setDriveStatus({ type: 'success', message: `Se encontraron ${files.reduce((sum, f) => sum + f.files.length, 0)} archivos .ent` });
                } catch (error) {
                    console.error('Error al conectar con Google Drive:', error);
                    if (error.message.includes('API key')) {
                        setDriveStatus({ type: 'error', message: 'Error de API Key. Verifica la configuración.' });
                    } else if (error.message.includes('not found') || error.message.includes('404')) {
                        setDriveStatus({ type: 'error', message: 'Carpeta no encontrada. Verifica que la URL sea correcta.' });
                    } else if (error.message.includes('permission') || error.message.includes('403')) {
                        setDriveStatus({ type: 'error', message: 'Sin permisos. La carpeta debe ser pública (compartida con "Cualquier persona con el enlace").' });
                    } else {
                        setDriveStatus({ type: 'error', message: `Error: ${error.message}` });
                    }
                }
            };

            const fetchDriveFile = async (fileId) => {
                const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media&key=${GOOGLE_API_KEY}`;
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('No se pudo descargar el archivo');
                }
                return await response.json();
            };

            const handleLoadFromDrive = async (asExercise = false) => {
                if (!selectedDriveFile) return;

                setDriveStatus({ type: 'loading', message: 'Cargando archivo...' });

                try {
                    const data = await fetchDriveFile(selectedDriveFile.id);
                    
                    if (!data.tree || !data.sentence) {
                        setDriveStatus({ type: 'error', message: 'El archivo no tiene el formato esperado.' });
                        return;
                    }

                    if (asExercise) {
                        // Cargar como ejercicio
                        const originalSentence = data.sentence || '';
                        setSentence(originalSentence);
                        setModelTree(data.tree);
                        const newTree = createEmptyTree(originalSentence);
                        setTree(newTree);
                        setDivisionMode(null);
                        setSelectedCuts([]);
                        setExerciseMode(true);
                        setShowComparison(false);
                        setComparisonResults(null);
                        setHistory([JSON.stringify(newTree)]);
                        setHistoryIndex(0);
                        // Limpiar auto-guardado al cargar un archivo
                        localStorage.removeItem('ent-autosave');
                        setLastSaved(null);
                    } else {
                        // Cargar como referencia (para ver/editar)
                        setSentence(data.sentence || '');
                        setTree(data.tree);
                        setExerciseMode(false);
                        setModelTree(null);
                        setShowComparison(false);
                        setHistory([JSON.stringify(data.tree)]);
                        setHistoryIndex(0);
                        // Limpiar auto-guardado al cargar un archivo
                        localStorage.removeItem('ent-autosave');
                        setLastSaved(null);
                    }

                    setShowFilesModal(false);
                    setSelectedDriveFile(null);
                } catch (error) {
                    console.error('Error al cargar archivo:', error);
                    setDriveStatus({ type: 'error', message: `Error al cargar: ${error.message}` });
                }
            };

            const toggleFolder = (folderId) => {
                setCollapsedFolders(prev => ({
                    ...prev,
                    [folderId]: !prev[folderId]
                }));
            };

            // ===========================================
            // ATAJOS DE TECLADO
            // ===========================================
            useEffect(() => {
                const handleKeyDown = (e) => {
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const modifier = isMac ? e.metaKey : e.ctrlKey;
                    const key = e.key.toLowerCase();
                    
                    // Ignorar si estamos en un input/textarea
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        // Solo permitir atajos de guardar en inputs
                        if (modifier && key === 's') {
                            e.preventDefault();
                            handleSaveJSON();
                        }
                        return;
                    }
                    
                    if (modifier && key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        handleUndo();
                    } else if (modifier && key === 'z' && e.shiftKey) {
                        e.preventDefault();
                        handleRedo();
                    } else if (modifier && key === 'y') {
                        e.preventDefault();
                        handleRedo();
                    } else if (modifier && key === 's') {
                        e.preventDefault();
                        handleSaveJSON();
                    } else if (modifier && (key === '+' || key === '=')) {
                        e.preventDefault();
                        zoomIn();
                    } else if (modifier && key === '-') {
                        e.preventDefault();
                        zoomOut();
                    } else if (modifier && key === '0') {
                        e.preventDefault();
                        zoomReset();
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [handleUndo, handleRedo, handleSaveJSON, zoomIn, zoomOut, zoomReset]);

            // ===========================================
            // ACCIONES PRINCIPALES
            // ===========================================
            const startAnalysis = () => {
                if (sentence.trim()) {
                    const newTree = createEmptyTree(sentence);
                    setTree(newTree);
                    setDivisionMode(null);
                    setSelectedCuts([]);
                    setExerciseMode(false);
                    setModelTree(null);
                    setShowComparison(false);
                    // Reiniciar historial
                    setHistory([JSON.stringify(newTree)]);
                    setHistoryIndex(0);
                }
            };

            const handleDivide = () => {
                const node = findNodeById(tree, divisionMode);
                const words = node.text.split(/\s+/);
                const segments = [];
                let start = 0;
                
                // Asegurar que los cortes estén ordenados numéricamente
                const sortedCuts = [...selectedCuts].sort((a, b) => a - b);
                
                [...sortedCuts, words.length - 1].forEach(cut => {
                    segments.push(words.slice(start, cut + 1).join(' '));
                    start = cut + 1;
                });
                
                const children = segments.filter(s => s.trim()).map((s, i) => ({
                    id: `${divisionMode}-${i}-${Date.now()}`,
                    text: s,
                    labelTop: '',
                    labelBottom: '',
                    children: null,
                    isNucleus: false,
                    isConsolidated: false
                }));
                
                setTree(prev => updateNode(prev, divisionMode, { children }));
                setDivisionMode(null);
                setSelectedCuts([]);
            };

            const toggleConsolidated = (nodeId) => {
                setTree(prev => {
                    const node = findNodeById(prev, nodeId);
                    return updateNode(prev, nodeId, { isConsolidated: !node.isConsolidated });
                });
            };

            const expandNode = (nodeId) => {
                setTree(prev => {
                    const node = findNodeById(prev, nodeId);
                    if (!node || node.children) return prev;
                    
                    // Crear un hijo con el mismo texto del nodo padre
                    const childNode = {
                        id: `${nodeId}-child-${Date.now()}`,
                        text: node.text,
                        labelTop: '',
                        labelBottom: '',
                        children: null,
                        isNucleus: node.isNucleus,
                        isConsolidated: false
                    };
                    
                    return updateNode(prev, nodeId, { 
                        children: [childNode],
                        isNucleus: false
                    });
                });
            };

            const addChildNode = (parentId) => {
                const txt = window.prompt('Texto del nodo extra:');
                if (txt === null) return;

                const parent = findNodeById(tree, parentId);
                const existing = parent?.children ? [...parent.children] : [];
                const siblings = existing.map(c => (c.text || '').trim() || '∅');

                setPosPicker({
                    parentId,
                    txt: txt.trim(),
                    siblings,
                    pos: 1
                });
            };

            const confirmInsertAtPosition = () => {
                if (!posPicker) return;
                const { parentId, txt, pos } = posPicker;

                setTree(prev => {
                    const parent = findNodeById(prev, parentId);
                    const existing = parent?.children ? [...parent.children] : [];
                    const n = existing.length;
                    let p = parseInt(pos, 10);
                    if (Number.isNaN(p)) p = n + 1;
                    p = Math.max(1, Math.min(n + 1, p));

                    const newNode = makeNewNode(txt);
                    existing.splice(p - 1, 0, newNode);
                    return updateNode(prev, parentId, { children: existing });
                });

                setPosPicker(null);
            };

            // ===========================================
            // CARGAR ARCHIVOS
            // ===========================================
            const handleLoadJSON = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!imported.tree || !imported.sentence) {
                            alert('Error: El archivo no tiene el formato esperado.\n\nEl archivo debe contener las propiedades "sentence" y "tree".');
                            return;
                        }
                        setSentence(imported.sentence || '');
                        setTree(imported.tree);
                        setExerciseMode(false);
                        setModelTree(null);
                        setShowComparison(false);
                        // Reiniciar historial con el árbol cargado
                        setHistory([JSON.stringify(imported.tree)]);
                        setHistoryIndex(0);
                    } catch (error) {
                        alert('Error al leer el archivo.\n\nEl archivo no tiene un formato válido (.ent o .json) o está corrupto.\n\nDetalle: ' + error.message);
                    }
                };
                reader.onerror = () => {
                    alert('Error al leer el archivo. Por favor, inténtelo de nuevo.');
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            const handleLoadExercise = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        if (!imported.tree || !imported.sentence) {
                            alert('Error: El archivo no tiene el formato esperado.\n\nEl archivo de ejercicio debe contener las propiedades "sentence" y "tree".');
                            return;
                        }
                        const originalSentence = imported.sentence || '';
                        setSentence(originalSentence);
                        setModelTree(imported.tree);
                        const newTree = createEmptyTree(originalSentence);
                        setTree(newTree);
                        setDivisionMode(null);
                        setSelectedCuts([]);
                        setExerciseMode(true);
                        setShowComparison(false);
                        setComparisonResults(null);
                        // Reiniciar historial
                        setHistory([JSON.stringify(newTree)]);
                        setHistoryIndex(0);
                    } catch (error) {
                        alert('Error al leer el archivo de ejercicio.\n\nEl archivo no es válido o está corrupto.\n\nDetalle: ' + error.message);
                    }
                };
                reader.onerror = () => {
                    alert('Error al leer el archivo. Por favor, inténtelo de nuevo.');
                };
                reader.readAsText(file);
                event.target.value = '';
            };

            // ===========================================
            // MODO EJERCITACIÓN
            // ===========================================
            const compareTrees = (studentTree, modelTree) => {
                const results = {
                    totalNodes: 0,
                    correctNodes: 0,
                    totalLabelTopParts: 0,
                    totalLabelBottomParts: 0,
                    correctLabelTopParts: 0,
                    correctLabelBottomParts: 0,
                    totalElements: 0,
                    correctElements: 0,
                    errorElements: 0,
                    accuracy: 0,
                    nodeComparisons: new Map()
                };

                const normalizeText = (text) => (text || '').trim().toLowerCase();
                
                // Extrae las partes normalizadas de una etiqueta
                const getLabelParts = (label) => {
                    if (!label) return [];
                    return label.split('/')
                        .map(p => p.trim().toLowerCase().replace(/\s+/g, ''))
                        .filter(p => p);
                };
                
                // Normaliza una etiqueta completa (para comparación de igualdad total)
                const normalizeLabel = (label) => {
                    const parts = getLabelParts(label);
                    return parts.sort().join('•');
                };
                
                // Compara dos etiquetas y retorna cuántas partes del modelo fueron acertadas
                const compareLabelParts = (studentLabel, modelLabel) => {
                    const studentParts = getLabelParts(studentLabel);
                    const modelParts = getLabelParts(modelLabel);
                    
                    if (modelParts.length === 0) {
                        return { total: 0, correct: 0, allMatch: true };
                    }
                    
                    const studentSet = new Set(studentParts);
                    let correct = 0;
                    for (const part of modelParts) {
                        if (studentSet.has(part)) correct++;
                    }
                    
                    // allMatch es true si todas las partes coinciden (mismo contenido, sin importar orden)
                    const allMatch = correct === modelParts.length && studentParts.length === modelParts.length;
                    
                    return { total: modelParts.length, correct, allMatch };
                };
                
                const getChildCount = (node) => (node?.children?.length) || 0;

                // Verifica si los hijos del estudiante coinciden con los del modelo
                // Para nodos normales: verificar texto exacto en la misma posición
                // Para nodos extra (isInserted): solo verificar que las etiquetas coincidan (ignorar texto y posición)
                const childrenMatch = (studentNode, modelNode) => {
                    const studentChildren = studentNode?.children || [];
                    const modelChildren = modelNode?.children || [];
                    
                    // Separar nodos normales y nodos extra
                    const studentNormal = studentChildren.filter(c => !c.isInserted);
                    const studentExtra = studentChildren.filter(c => c.isInserted);
                    const modelNormal = modelChildren.filter(c => !c.isInserted);
                    const modelExtra = modelChildren.filter(c => c.isInserted);
                    
                    // Verificar que la cantidad de nodos normales coincida
                    if (studentNormal.length !== modelNormal.length) return false;
                    
                    // Verificar que la cantidad de nodos extra coincida
                    if (studentExtra.length !== modelExtra.length) return false;
                    
                    // Verificar que cada nodo normal tenga el mismo texto en la misma posición
                    for (let i = 0; i < modelNormal.length; i++) {
                        if (normalizeText(studentNormal[i]?.text) !== normalizeText(modelNormal[i]?.text)) {
                            return false;
                        }
                    }
                    
                    // Para nodos extra: verificar que cada nodo extra del estudiante 
                    // tenga etiquetas que coincidan con algún nodo extra del modelo
                    const usedModelExtras = new Set();
                    for (const studentExtraNode of studentExtra) {
                        const studentLabelTop = normalizeLabel(studentExtraNode.labelTop);
                        const studentLabelBottom = normalizeLabel(studentExtraNode.labelBottom);
                        
                        // Buscar un nodo extra del modelo con las mismas etiquetas que aún no haya sido usado
                        let foundMatch = false;
                        for (let j = 0; j < modelExtra.length; j++) {
                            if (usedModelExtras.has(j)) continue;
                            
                            const modelLabelTop = normalizeLabel(modelExtra[j].labelTop);
                            const modelLabelBottom = normalizeLabel(modelExtra[j].labelBottom);
                            
                            if (studentLabelTop === modelLabelTop && studentLabelBottom === modelLabelBottom) {
                                usedModelExtras.add(j);
                                foundMatch = true;
                                break;
                            }
                        }
                        
                        if (!foundMatch) return false;
                    }
                    
                    return true;
                };

                // Cuenta todos los elementos del modelo (para el puntaje total)
                const countModelElements = (modelNode) => {
                    const children = modelNode.children || [];
                    children.forEach((child) => {
                        results.totalNodes++;
                        const topParts = getLabelParts(child.labelTop);
                        const bottomParts = getLabelParts(child.labelBottom);
                        results.totalLabelTopParts += topParts.length;
                        results.totalLabelBottomParts += bottomParts.length;
                        countModelElements(child);
                    });
                };

                const compareNodes = (student, model, path = 'root') => {
                    if (!model) return;
                    
                    // 1. PUNTAJE IDEAL: Siempre se suma basándose exclusivamente en el modelo
                    results.totalNodes++;
                    const modelTopParts = getLabelParts(model.labelTop);
                    const modelBottomParts = getLabelParts(model.labelBottom);
                    // Para nodos extra, solo contamos el nodo (las etiquetas se evalúan como parte de la identificación)
                    if (!model.isInserted) {
                        results.totalLabelTopParts += modelTopParts.length;
                        results.totalLabelBottomParts += modelBottomParts.length;
                    }

                    // 2. Verificar si el estudiante tiene este nodo y si está correctamente identificado
                    const hasStudent = !!student;
                    const isExtraNode = model.isInserted;
                    
                    // Para nodos normales: verificar que el texto coincida
                    // Para nodos extra (isInserted): verificar que las etiquetas coincidan (ignorar texto)
                    let nodeIdentifiedCorrectly;
                    if (isExtraNode) {
                        // Nodo extra: identificado correctamente si las etiquetas coinciden
                        nodeIdentifiedCorrectly = hasStudent && 
                            normalizeLabel(student.labelTop) === normalizeLabel(model.labelTop) &&
                            normalizeLabel(student.labelBottom) === normalizeLabel(model.labelBottom);
                    } else {
                        // Nodo normal: identificado correctamente si el texto coincide
                        nodeIdentifiedCorrectly = hasStudent && normalizeText(student.text) === normalizeText(model.text);
                    }
                    
                    // 3. Verificar si la división es correcta (hijos coinciden exactamente)
                    const divisionCorrect = nodeIdentifiedCorrectly && childrenMatch(student, model);
                    
                    // 4. Comparar etiquetas por partes
                    const topComparison = hasStudent 
                        ? compareLabelParts(student.labelTop, model.labelTop)
                        : { total: modelTopParts.length, correct: 0, allMatch: modelTopParts.length === 0 };
                    const bottomComparison = hasStudent 
                        ? compareLabelParts(student.labelBottom, model.labelBottom)
                        : { total: modelBottomParts.length, correct: 0, allMatch: modelBottomParts.length === 0 };

                    const comparison = {
                        path,
                        // El nodo está correctamente identificado
                        nodeCorrect: nodeIdentifiedCorrectly,
                        // La división es correcta (hijos coinciden)
                        divisionCorrect,
                        // Comparación completa de etiquetas (todas las partes coinciden)
                        labelTopMatch: topComparison.allMatch,
                        labelBottomMatch: bottomComparison.allMatch,
                        // Información detallada de partes para visualización
                        labelTopComparison: topComparison,
                        labelBottomComparison: bottomComparison,
                        studentNode: hasStudent ? student : null,
                        modelNode: model,
                        isExtraNode,
                        // Flag que indica si debemos mostrar mensaje de error y truncar
                        // (nodo identificado correctamente pero mal dividido)
                        shouldTruncate: nodeIdentifiedCorrectly && !divisionCorrect && (getChildCount(model) > 0 || getChildCount(student) > 0)
                    };

                    // 5. ACIERTOS
                    // El nodo cuenta como acierto si está correctamente identificado
                    if (nodeIdentifiedCorrectly) {
                        results.correctNodes++;
                    }
                    // Las etiquetas se evalúan por partes
                    // Para nodos extra, las etiquetas ya se contaron como parte de nodeIdentifiedCorrectly
                    if (!isExtraNode && hasStudent) {
                        results.correctLabelTopParts += topComparison.correct;
                        results.correctLabelBottomParts += bottomComparison.correct;
                    }

                    results.nodeComparisons.set(path, comparison);

                    // 6. RECURSIÓN: Solo continuar si la división es correcta
                    if (divisionCorrect) {
                        const modelChildren = model.children || [];
                        const studentChildren = student?.children || [];
                        
                        // Separar nodos normales y extra
                        const modelNormal = modelChildren.filter(c => !c.isInserted);
                        const modelExtra = modelChildren.filter(c => c.isInserted);
                        const studentNormal = studentChildren.filter(c => !c.isInserted);
                        const studentExtra = studentChildren.filter(c => c.isInserted);
                        
                        // Emparejar nodos normales por posición
                        modelNormal.forEach((modelChild, mi) => {
                            const studentChild = studentNormal[mi] || null;
                            compareNodes(studentChild, modelChild, `${path}-n${mi}`);
                        });
                        
                        // Emparejar nodos extra por etiquetas
                        const usedStudentExtras = new Set();
                        modelExtra.forEach((modelChild, mi) => {
                            const modelLabelTop = normalizeLabel(modelChild.labelTop);
                            const modelLabelBottom = normalizeLabel(modelChild.labelBottom);
                            
                            // Buscar un nodo extra del estudiante con las mismas etiquetas
                            let matchedStudent = null;
                            for (let si = 0; si < studentExtra.length; si++) {
                                if (usedStudentExtras.has(si)) continue;
                                
                                const studentLabelTop = normalizeLabel(studentExtra[si].labelTop);
                                const studentLabelBottom = normalizeLabel(studentExtra[si].labelBottom);
                                
                                if (studentLabelTop === modelLabelTop && studentLabelBottom === modelLabelBottom) {
                                    usedStudentExtras.add(si);
                                    matchedStudent = studentExtra[si];
                                    break;
                                }
                            }
                            
                            compareNodes(matchedStudent, modelChild, `${path}-e${mi}`);
                        });
                    } else {
                        // Si hay error de división (o nodo no identificado), contar elementos restantes 
                        // del modelo para puntaje total, pero NO sumar aciertos
                        countModelElements(model);
                    }
                };

                compareNodes(studentTree, modelTree, 'root');

                results.totalElements = results.totalNodes + results.totalLabelTopParts + results.totalLabelBottomParts;
                results.correctElements = results.correctNodes + results.correctLabelTopParts + results.correctLabelBottomParts;
                results.errorElements = results.totalElements - results.correctElements;
                results.accuracy = results.totalElements ? (results.correctElements / results.totalElements) : 1;

                return results;
            };

            const handleFinishExercise = () => {
                if (!tree || !modelTree) return;
                const results = compareTrees(tree, modelTree);
                setComparisonResults(results);
                setShowComparison(true);
            };

            const resetExercise = () => {
                setExerciseMode(false);
                setModelTree(null);
                setShowComparison(false);
                setComparisonResults(null);
                setTree(null);
                setSentence('');
                // Reiniciar historial
                setHistory([]);
                setHistoryIndex(-1);
                // Limpiar auto-guardado
                localStorage.removeItem('ent-autosave');
                setLastSaved(null);
            };

            const newExercise = () => {
                setExerciseMode(true);
                setModelTree(null);
                setShowComparison(false);
                setComparisonResults(null);
                setTree(null);
                setSentence('');
                setDivisionMode(null);
                setSelectedCuts([]);
                // Reiniciar historial
                setHistory([]);
                setHistoryIndex(-1);
                // Limpiar auto-guardado
                localStorage.removeItem('ent-autosave');
                setLastSaved(null);
            };

            // ===========================================
            // EXPORTACIÓN
            // ===========================================
            const handleExport = async (isTechnical = false) => {
                const treeWrapper = document.querySelector('.tree-container .tree-wrapper');
                if (!treeWrapper) return;

                const treeContainer = document.querySelector('.tree-container');
                const zoomContainer = treeContainer.querySelector('.zoom-container');
                
                // Guardar zoom actual y resetear a 100% para exportación consistente
                const savedZoom = zoomLevel;
                setZoomLevel(100);
                
                // Esperar a que React re-renderice con zoom al 100%
                await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
                await new Promise(resolve => setTimeout(resolve, 50));

                try {

                const originalOverflow = treeContainer.style.overflow;
                const originalWidth = treeContainer.style.width;
                const originalMaxWidth = treeContainer.style.maxWidth;
                treeContainer.style.overflow = 'visible';
                treeContainer.style.width = 'fit-content';
                treeContainer.style.maxWidth = 'none';

                if (isTechnical) treeWrapper.classList.add('technical-mode');

                // Ocultar botones de edición y controles de zoom
                const undoBtns = treeWrapper.querySelectorAll('.btn-danger-soft');
                const clearBtns = treeWrapper.querySelectorAll('.clear-text-btn');
                const addBtns = treeWrapper.querySelectorAll('.add-node-btn');
                const splitBtns = treeWrapper.querySelectorAll('.split-toggle-btn');
                const zoomControls = treeContainer.querySelector('.zoom-controls');

                undoBtns.forEach(b => b.style.visibility = 'hidden');
                clearBtns.forEach(b => b.style.display = 'none');
                addBtns.forEach(b => b.style.display = 'none');
                splitBtns.forEach(b => b.style.display = 'none');
                if (zoomControls) zoomControls.style.display = 'none';

                let svg = null;
                const connectors = treeWrapper.querySelectorAll('.connector-v, .v-line-stem');
                const nodeBoxes = treeWrapper.querySelectorAll('.node-box');
                const inputData = [];

                const originalInlineStyles = {
                    connectors: Array.from(connectors).map(el => ({ el, cssText: el.style.cssText })),
                    nodeBoxes: Array.from(nodeBoxes).map(el => ({ el, cssText: el.style.cssText })),
                    treeWrapperPos: treeWrapper.style.position
                };

                // Función auxiliar para obtener valor de etiqueta (de input o display)
                const getLabelValue = (element) => {
                    if (!element) return '';
                    if (element.tagName === 'INPUT') {
                        return element.value.trim();
                    } else {
                        // Para label-display, usar data-raw-value si existe para preservar marcadores de formato
                        const rawValue = element.getAttribute('data-raw-value');
                        if (rawValue !== null) {
                            return rawValue.trim();
                        }
                        return element.textContent.trim();
                    }
                };

                const nodeContainers = treeWrapper.querySelectorAll('.node-container');
                
                nodeContainers.forEach(container => {
                    // Buscar tanto inputs como displays (incluyendo los que están dentro de label-with-dropdown)
                    const topElements = container.querySelectorAll(':scope > .label-wrap > .label-input.label-top, :scope > .label-wrap > .label-display.label-top, :scope > .label-wrap > .label-with-dropdown > .label-input.label-top, :scope > .label-wrap > .label-with-dropdown > .label-display.label-top');
                    const bottomElements = container.querySelectorAll(':scope > .label-wrap > .label-input:not(.label-top), :scope > .label-wrap > .label-display:not(.label-top), :scope > .label-wrap > .label-with-dropdown > .label-input:not(.label-top), :scope > .label-wrap > .label-with-dropdown > .label-display:not(.label-top)');
                    
                    // El node-box está dentro de un div flex que es hijo directo del container
                    // IMPORTANTE: Solo buscar en los hijos directos, NO en descendientes
                    let nodeBox = null;
                    const directChildren = container.children;
                    for (let child of directChildren) {
                        // Si es un div que NO tiene children-container y NO es connector-v
                        if (child.tagName === 'DIV' && 
                            !child.classList.contains('connector-v') && 
                            !child.classList.contains('label-wrap') &&
                            !child.querySelector(':scope > .children-container')) {
                            // Buscar node-box como hijo directo de este div
                            const box = child.querySelector(':scope > .node-box');
                            if (box) {
                                nodeBox = box;
                                break;
                            }
                        }
                    }
                    
                    const hasChildren = container.querySelector(':scope > div > .children-container') !== null;
                    const isNucleus = container.classList.contains('nucleus-node');
                    const isRootNode = container.parentElement && container.parentElement.classList.contains('tree-wrapper');

                    const topVal = Array.from(topElements).map(el => getLabelValue(el)).filter(v => v && v !== 'func.' && v !== 'cat.').join(' • ');
                    const botVal = Array.from(bottomElements).map(el => getLabelValue(el)).filter(v => v && v !== 'func.' && v !== 'cat.').join(' • ');

                    const slashSeparators = container.querySelectorAll(':scope > .label-wrap > .slash-separator');
                    slashSeparators.forEach(s => s.style.display = 'none');
                    
                    // Ocultar label-wraps completos
                    const labelWraps = container.querySelectorAll(':scope > .label-wrap');

                    if (isTechnical && hasChildren) {
                        // En modo técnico con hijos, NO extraemos ni mostramos el texto del nodo
                        // para evitar redundancia y desalineación en el diagrama arbóreo.
                        if (nodeBox) nodeBox.style.display = 'none';
                        
                        let combinedText = '';
                        if (topVal && botVal) combinedText = `${topVal} • ${botVal}`;
                        else if (topVal) combinedText = `${topVal}`;
                        else if (botVal) combinedText = `${botVal}`;
                        
                        const mergedSpan = document.createElement('span');
                        mergedSpan.className = 'exp-merged';
                        mergedSpan.style.cssText = `display: block; text-align: center; font-size: 16px; color: #111827; font-weight: ${isNucleus ? 'bold' : 'normal'}; padding: 4px; text-transform: uppercase;`;
                        applyFormatToSpan(mergedSpan, combinedText.toUpperCase());
                        
                        labelWraps.forEach(lw => lw.style.display = 'none');

                        inputData.push({ type: 'merged', labelWraps, box: nodeBox, span: mergedSpan, textSpan: null, parent: container, slashSeparators });
                        
                        // Insertar mergedSpan al principio del container
                        container.insertBefore(mergedSpan, container.firstChild);
                    } else {
                        const processLabels = (elements, isTop, combinedVal, labelWrap) => {
                            const span = document.createElement('span');
                            
                            if (!combinedVal) {
                                span.style.display = 'none';
                                const allConnectors = container.querySelectorAll(':scope > .connector-v');

                                if (isTop) {
                                    if (allConnectors.length >= 1) {
                                        if (!isTechnical && isRootNode) {
                                            allConnectors[0].style.display = 'none';
                                            inputData.push({ type: 'connector-hidden', connector: allConnectors[0] });
                                        } else {
                                            const currentHeight = parseInt(window.getComputedStyle(allConnectors[0]).height) || 12;
                                            const extraHeight = 23;
                                            allConnectors[0].dataset.originalHeight = currentHeight;
                                            allConnectors[0].style.height = (currentHeight + extraHeight) + 'px';
                                            inputData.push({ type: 'connector-extended', connector: allConnectors[0] });
                                        }
                                    }
                                } else {
                                    if (allConnectors.length >= 2) {
                                        allConnectors[1].style.display = 'none';
                                        inputData.push({ type: 'connector-hidden', connector: allConnectors[1] });
                                    }
                                }
                            } else {
                                let val = combinedVal;
                                if (isTechnical) val = `[${val}]`;
                                
                                span.className = isTop ? 'exp-top' : 'exp-bottom';
                                const textColor = isTechnical ? '#6b7280' : '#334155';
                                const transform = isTop ? 'uppercase' : 'none';
                                let marginStyle = isTechnical ? (isTop ? 'margin-bottom: 2px;' : 'margin-top: 2px;') : '';
                                const borderStyle = isTechnical ? 'none' : '1px solid #cbd5e1';
                                const bgStyle = isTechnical ? 'transparent' : '#f1f5f9';

                                span.style.cssText = `${marginStyle} display: inline-block; min-width: 95px; text-align: center; font-size: 11px; font-family: Arial, sans-serif; padding: 4px; border: ${borderStyle}; border-radius: 4px; background-color: ${bgStyle}; color: ${textColor}; font-weight: ${container.classList.contains('nucleus-node') ? 'bold' : 'normal'}; text-transform: ${transform};`;
                                applyFormatToSpan(span, isTop ? val.toUpperCase() : val);
                            }
                            
                            if (labelWrap) {
                                labelWrap.style.display = 'none';
                            }

                            inputData.push({ type: 'single', labelWrap, span, parent: container, isTop });
                            
                            if (isTop) {
                                container.insertBefore(span, container.firstChild);
                            } else {
                                const childrenDiv = container.querySelector(':scope > div:last-child');
                                if (childrenDiv && childrenDiv.querySelector('.children-container')) {
                                    container.insertBefore(span, childrenDiv);
                                } else {
                                    container.appendChild(span);
                                }
                            }
                        };
                        
                        // Encontrar los label-wraps para top y bottom
                        const topLabelWrap = Array.from(labelWraps).find(lw => lw.querySelector('.label-top'));
                        const bottomLabelWrap = Array.from(labelWraps).find(lw => lw.querySelector(':not(.label-top)') && !lw.querySelector('.label-top'));
                        
                        processLabels(Array.from(topElements), true, topVal, topLabelWrap);
                        processLabels(Array.from(bottomElements), false, botVal, bottomLabelWrap || (labelWraps[1] || null));
                    }
                });

                if (isTechnical) {
                    connectors.forEach(c => c.style.display = 'none');
                    nodeBoxes.forEach(b => { 
                        if (b && b.style.display !== 'none') { 
                            b.style.border = 'none'; 
                            b.style.backgroundColor = 'transparent'; 
                        }
                    });
                    
                    const rect = treeWrapper.getBoundingClientRect();
                    svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('width', rect.width);
                    svg.setAttribute('height', rect.height);
                    svg.style.cssText = `position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;`;
                    treeWrapper.style.position = 'relative';
                    treeWrapper.appendChild(svg);
                    
                    const getPos = (el) => {
                        const r = el.getBoundingClientRect();
                        return { x: r.left + r.width / 2 - rect.left, top: r.top - rect.top, bottom: r.bottom - rect.top };
                    };
                    
                    // Función auxiliar para encontrar el node-box directo de un container
                    const findDirectNodeBox = (container) => {
                        const directChildren = container.children;
                        for (let child of directChildren) {
                            // Si es un div que NO tiene children-container, connector-v o label-wrap
                            if (child.tagName === 'DIV' && 
                                !child.classList.contains('connector-v') && 
                                !child.classList.contains('label-wrap') &&
                                !child.querySelector(':scope > .children-container')) {
                                const box = child.querySelector(':scope > .node-box');
                                if (box) return box;
                            }
                        }
                        return null;
                    };
                    
                    const getTopConnectionPoint = (container) => {
                        const merged = container.querySelector(':scope > .exp-merged');
                        if (merged) return merged;
                        const expTop = container.querySelector(':scope > .exp-top');
                        if (expTop && expTop.style.display !== 'none') return expTop;
                        const nodeBox = findDirectNodeBox(container);
                        if (nodeBox && nodeBox.style.display !== 'none') return nodeBox;
                        const expBottom = container.querySelector(':scope > .exp-bottom');
                        if (expBottom && expBottom.style.display !== 'none') return expBottom;
                        return null;
                    };
                    
                    treeWrapper.querySelectorAll('.node-container').forEach(cont => {
                        const pLabel = cont.querySelector(':scope > .exp-merged');
                        const textNode = cont.querySelector(':scope > .exp-text-node');
                        const nodeBox = findDirectNodeBox(cont);
                        const branches = cont.querySelector(':scope > div > .children-container');
                        
                        if (pLabel && branches) {
                            // Usar exp-merged (ya que nodeBox y textSpan están ocultos/nulos en modo técnico para padres)
                            let connectionSource = pLabel;
                            if (textNode && textNode.textContent.trim()) {
                                connectionSource = textNode;
                            }
                            const pPos = getPos(connectionSource);
                            Array.from(branches.children).forEach(branch => {
                                const childContainer = branch.querySelector(':scope > .node-container');
                                if (childContainer) {
                                    const cTarget = getTopConnectionPoint(childContainer);
                                    if (cTarget) {
                                        const cPos = getPos(cTarget);
                                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                        line.setAttribute('x1', pPos.x);
                                        line.setAttribute('y1', pPos.bottom);
                                        line.setAttribute('x2', cPos.x);
                                        line.setAttribute('y2', cPos.top);
                                        line.setAttribute('stroke', 'black');
                                        line.setAttribute('stroke-width', '1.5');
                                        svg.appendChild(line);
                                    }
                                }
                            });
                        }
                    });
                }

                const canvas = await html2canvas(treeWrapper, { 
                    backgroundColor: null, 
                    scale: 2,
                    width: treeWrapper.scrollWidth,
                    height: treeWrapper.scrollHeight
                });
                
                const link = document.createElement('a');
                link.download = getFileName('png');
                link.href = canvas.toDataURL();
                link.click();

                // Restaurar estilos
                treeContainer.style.overflow = originalOverflow;
                treeContainer.style.width = originalWidth;
                treeContainer.style.maxWidth = originalMaxWidth;

                if (isTechnical) treeWrapper.classList.remove('technical-mode');
                if (svg) svg.remove();
                treeWrapper.style.position = originalInlineStyles.treeWrapperPos;
                
                inputData.forEach(d => {
                    if (d.type === 'connector-hidden') {
                        d.connector.style.display = '';
                    } else if (d.type === 'connector-extended') {
                        const originalHeight = d.connector.dataset.originalHeight || '12';
                        d.connector.style.height = originalHeight + 'px';
                        delete d.connector.dataset.originalHeight;
                    } else if (d.type === 'merged') {
                        d.span.remove();
                        if (d.textSpan) d.textSpan.remove();
                        d.labelWraps.forEach(lw => lw.style.display = '');
                        if (d.box) d.box.style.display = '';
                        d.slashSeparators.forEach(s => s.style.display = '');
                    } else {
                        d.span.remove();
                        if (d.labelWrap) {
                            d.labelWrap.style.display = '';
                        }
                    }
                });
                
                originalInlineStyles.connectors.forEach(({ el, cssText }) => { el.style.cssText = cssText; });
                originalInlineStyles.nodeBoxes.forEach(({ el, cssText }) => { el.style.cssText = cssText; });

                undoBtns.forEach(b => b.style.visibility = 'visible');
                clearBtns.forEach(b => b.style.display = '');
                addBtns.forEach(b => b.style.display = '');
                splitBtns.forEach(b => b.style.display = '');
                if (zoomControls) zoomControls.style.display = '';
                
            } finally {
                setZoomLevel(savedZoom);
            }
            };

            // ===========================================
            // RENDERIZADO DE ETIQUETAS CON DROPDOWN GTG
            // ===========================================
            const [editingLabel, setEditingLabel] = useState(null);
            const [dropdownOpen, setDropdownOpen] = useState(null);
            const [dropdownSearch, setDropdownSearch] = useState('');

            // Componente Dropdown para seleccionar etiquetas GTG
            const LabelDropdown = ({ isTop, onSelect, onClose }) => {
                const sections = isTop ? FUNC_SECTIONS : CAT_SECTIONS;
                const searchLower = dropdownSearch.toLowerCase();
                
                const filteredSections = sections.map(sectionKey => {
                    const section = GTG_LABELS[sectionKey];
                    const filtered = section.items.filter(item => 
                        item.abbr.toLowerCase().includes(searchLower) ||
                        item.full.toLowerCase().includes(searchLower)
                    );
                    return { ...section, items: filtered, key: sectionKey };
                }).filter(s => s.items.length > 0);

                return (
                    <div className="label-dropdown" onClick={(e) => e.stopPropagation()}>
                        <div className="dropdown-search">
                            <input
                                type="text"
                                placeholder="Buscar etiqueta..."
                                value={dropdownSearch}
                                onChange={(e) => setDropdownSearch(e.target.value)}
                                autoFocus
                                onClick={(e) => e.stopPropagation()}
                            />
                        </div>
                        {filteredSections.map(section => (
                            <div key={section.key} className="dropdown-section">
                                <div className="dropdown-section-title">{section.title}</div>
                                {section.items.map(item => (
                                    <div 
                                        key={item.abbr}
                                        className="dropdown-item"
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            e.preventDefault();
                                            onSelect(item.abbr);
                                        }}
                                    >
                                        <span className="dropdown-item-abbr">{item.abbr}</span>
                                        <span className="dropdown-item-full">{item.full}</span>
                                    </div>
                                ))}
                            </div>
                        ))}
                        {filteredSections.length === 0 && (
                            <div className="dropdown-empty">Sin resultados</div>
                        )}
                    </div>
                );
            };

            // Cerrar dropdown al hacer clic fuera
            const dropdownRef = useRef(null);
            
            useEffect(() => {
                const handleClickOutside = (e) => {
                    // Si no hay dropdown abierto, no hacer nada
                    if (!dropdownOpen) return;
                    
                    // Buscar si el clic fue dentro de algún dropdown o botón trigger
                    const clickedDropdown = e.target.closest('.label-dropdown');
                    const clickedTrigger = e.target.closest('.dropdown-trigger');
                    
                    // Si el clic fue fuera de dropdowns y triggers, cerrar
                    if (!clickedDropdown && !clickedTrigger) {
                        setDropdownOpen(null);
                        setDropdownSearch('');
                    }
                };
                
                // Usar setTimeout para que el listener se agregue después del render
                const timeoutId = setTimeout(() => {
                    document.addEventListener('click', handleClickOutside);
                }, 0);
                
                return () => {
                    clearTimeout(timeoutId);
                    document.removeEventListener('click', handleClickOutside);
                };
            }, [dropdownOpen]);

            const renderLabelInput = (node, field, isTop) => {
                const value = (node[field] || '');
                const parts = value.split('/').map(p => p.trim());
                const isSplit = parts.length > 1;
                const hasValue = value.trim() !== '';
                const isEditing = editingLabel === `${node.id}-${field}`;
                const dropdownId = `${node.id}-${field}`;
                const baseClass = `label-input ${isTop ? 'label-top' : ''} ${hasValue ? (isTop ? 'has-value-top' : 'has-value-bottom') : ''}`;

                const setValue = (newVal) => setTree(prev => updateNode(prev, node.id, { [field]: newVal }));

                const toggleSplit = (e) => {
                    e.stopPropagation();
                    if (isSplit) {
                        const left = (parts[0] || '').trim();
                        const right = (parts.slice(1).join('/').trim() || '');
                        setValue((left || right || '').trim());
                    } else {
                        const left = value.trim();
                        setValue((left ? left : '') + ' / ');
                    }
                };

                const startEditing = () => {
                    setEditingLabel(`${node.id}-${field}`);
                };

                const handleBlur = (e) => {
                    const labelWrap = e.currentTarget.closest('.label-wrap');
                    const relatedTarget = e.relatedTarget;
                    
                    // Si el foco va a otro elemento dentro del mismo label-wrap (incluido el dropdown), no cerrar
                    if (labelWrap && relatedTarget && labelWrap.contains(relatedTarget)) {
                        return;
                    }
                    
                    // Si el foco va a un botón de dropdown o al dropdown mismo, no cerrar
                    if (relatedTarget && (relatedTarget.closest('.dropdown-trigger') || relatedTarget.closest('.label-dropdown'))) {
                        return;
                    }
                    
                    setTimeout(() => {
                        setEditingLabel(prev => {
                            if (prev === `${node.id}-${field}`) {
                                return null;
                            }
                            return prev;
                        });
                    }, 200);
                };

                const handleKeyDown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        setEditingLabel(null);
                    }
                };

                const handleDropdownSelect = (abbr, partIndex = null) => {
                    if (isSplit && partIndex !== null) {
                        const newParts = [...parts];
                        newParts[partIndex] = abbr;
                        setValue(newParts.join(' / '));
                    } else {
                        setValue(abbr);
                    }
                    setDropdownOpen(null);
                    setDropdownSearch('');
                    // Cerrar el modo edición para que la etiqueta se muestre en modo visualización
                    setEditingLabel(null);
                };

                const openDropdown = (e, suffix = '') => {
                    e.stopPropagation();
                    e.preventDefault();
                    const newId = dropdownId + suffix;
                    // Si ya está abierto este mismo dropdown, cerrarlo; si no, abrirlo
                    if (dropdownOpen === newId) {
                        setDropdownOpen(null);
                        setDropdownSearch('');
                    } else {
                        setDropdownOpen(newId);
                        setDropdownSearch('');
                    }
                };

                // Modo edición: mostrar inputs con botones de dropdown
                if (isEditing) {
                    return (
                        <div className="label-wrap">
                            {isSplit ? (
                                <>
                                    <div className="label-with-dropdown">
                                        <input
                                            type="text"
                                            value={parts[0] || ''}
                                            onChange={(e) => {
                                                const left = e.target.value;
                                                const right = parts.slice(1).join('/').trim();
                                                setValue(left + ' / ' + right);
                                            }}
                                            onBlur={handleBlur}
                                            onKeyDown={handleKeyDown}
                                            autoFocus
                                            className={baseClass}
                                            style={{ width: '65px' }}
                                            placeholder={isTop ? 'func.' : 'cat.'}
                                        />
                                        <button 
                                            type="button" 
                                            className="dropdown-trigger"
                                            onMouseDown={(e) => e.preventDefault()}
                                            onClick={(e) => openDropdown(e, '-0')}
                                            title="Seleccionar etiqueta del catálogo GTG (RAE)"
                                        >
                                            ☰
                                        </button>
                                        {dropdownOpen === `${dropdownId}-0` && (
                                            <LabelDropdown
                                                isTop={isTop}
                                                onSelect={(abbr) => handleDropdownSelect(abbr, 0)}
                                                onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                            />
                                        )}
                                    </div>
                                    <span className="slash-separator" style={{ color: '#6b7280', fontWeight: 'bold',
                                    whiteSpace: 'normal',
                                    wordBreak: 'normal',
                                    overflowWrap: 'normal',
                                    hyphens: 'manual', fontSize: '12px' }}>•</span>
                                    <div className="label-with-dropdown">
                                        <input
                                            type="text"
                                            value={parts.slice(1).join('/').trim()}
                                            onChange={(e) => {
                                                const right = e.target.value;
                                                const left = (parts[0] || '').trim();
                                                setValue(left + ' / ' + right);
                                            }}
                                            onBlur={handleBlur}
                                            onKeyDown={handleKeyDown}
                                            className={baseClass}
                                            style={{ width: '65px' }}
                                            placeholder={isTop ? 'func.' : 'cat.'}
                                        />
                                        <button 
                                            type="button" 
                                            className="dropdown-trigger"
                                            onMouseDown={(e) => e.preventDefault()}
                                            onClick={(e) => openDropdown(e, '-1')}
                                            title="Seleccionar etiqueta del catálogo GTG (RAE)"
                                        >
                                            ☰
                                        </button>
                                        {dropdownOpen === `${dropdownId}-1` && (
                                            <LabelDropdown
                                                isTop={isTop}
                                                onSelect={(abbr) => handleDropdownSelect(abbr, 1)}
                                                onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                            />
                                        )}
                                    </div>
                                </>
                            ) : (
                                <div className="label-with-dropdown">
                                    <input
                                        type="text"
                                        value={value}
                                        onChange={(e) => setValue(e.target.value)}
                                        onBlur={handleBlur}
                                        onKeyDown={handleKeyDown}
                                        autoFocus
                                        className={baseClass}
                                        style={{ width: '78px' }}
                                        placeholder={isTop ? 'func.' : 'cat.'}
                                    />
                                    <button 
                                        type="button" 
                                        className="dropdown-trigger"
                                        onMouseDown={(e) => e.preventDefault()}
                                        onClick={(e) => openDropdown(e)}
                                        title="Seleccionar etiqueta del catálogo GTG (RAE)"
                                    >
                                        ☰
                                    </button>
                                    {dropdownOpen === dropdownId && (
                                        <LabelDropdown
                                            isTop={isTop}
                                            onSelect={(abbr) => handleDropdownSelect(abbr)}
                                            onClose={() => { setDropdownOpen(null); setDropdownSearch(''); }}
                                        />
                                    )}
                                </div>
                            )}
                            <button
                                type="button"
                                className="split-toggle-btn"
                                title={isSplit ? 'Unir etiqueta' : 'Dividir etiqueta'}
                                onClick={toggleSplit}
                                aria-label={isSplit ? 'Unir etiqueta' : 'Dividir etiqueta'}
                            >
                                ⇄
                            </button>
                        </div>
                    );
                }

                // Modo visualización: mostrar texto formateado
                const displayClass = `label-display ${isTop ? 'label-top' : ''} ${hasValue ? 'has-value' : ''}`;

                return (
                    <div className="label-wrap">
                        {isSplit ? (
                            <>
                                <span 
                                    className={displayClass}
                                    style={{ width: '80px', minWidth: '80px' }}
                                    onClick={startEditing}
                                    data-raw-value={parts[0]?.trim() || ''}
                                >
                                    {parts[0]?.trim() ? formatLabelText(parts[0].trim()) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                                </span>
                                <span className="slash-separator" style={{ color: '#6b7280', fontWeight: 'bold',
                                    whiteSpace: 'normal',
                                    wordBreak: 'break-word', fontSize: '12px' }}>•</span>
                                <span 
                                    className={displayClass}
                                    style={{ width: '80px', minWidth: '80px' }}
                                    onClick={startEditing}
                                    data-raw-value={parts.slice(1).join('/').trim() || ''}
                                >
                                    {parts.slice(1).join('/').trim() ? formatLabelText(parts.slice(1).join('/').trim()) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                                </span>
                            </>
                        ) : (
                            <span 
                                className={displayClass}
                                style={{ width: '95px', minWidth: '95px' }}
                                onClick={startEditing}
                                data-raw-value={value || ''}
                            >
                                {hasValue ? formatLabelText(value) : <span style={{color: '#9ca3af'}}>{isTop ? 'func.' : 'cat.'}</span>}
                            </span>
                        )}
                        <button
                            type="button"
                            className="split-toggle-btn"
                            title={isSplit ? 'Unir etiqueta' : 'Dividir etiqueta'}
                            onClick={toggleSplit}
                            aria-label={isSplit ? 'Unir etiqueta' : 'Dividir etiqueta'}
                        >
                            ⇄
                        </button>
                    </div>
                );
            };

            // ===========================================
            // RENDERIZADO DE NODOS
            // ===========================================
            const renderNode = (node) => {
                const isDiv = divisionMode === node.id;
                const hasC = node.children && node.children.length > 0;
                const isEmpty = !node.text || node.text.trim() === '';
                const words = node.text ? node.text.split(/\s+/) : [];
                const canDivide = words.length > 1 && !node.isInserted && !node.isConsolidated;
                const canConsolidate = words.length > 1 && !node.isInserted && !hasC;
                // Nodos de una sola palabra pueden expandirse para agregar hijos
                const canExpand = words.length === 1 && !node.isInserted && !hasC;
                // Mostrar botón de negritas en nodos terminales (sin hijos)
                const isTerminal = !hasC;

                return (
                    <div
                        className={`node-container ${node.isNucleus ? 'nucleus-node' : ''}`}
                        key={node.id}
                    >
                        {renderLabelInput(node, 'labelTop', true)}
                        
                        {isEmpty ? (
                            <div className="connector-v" style={{ height: '36px' }} />
                        ) : (
                            <>
                                <div className="connector-v" style={{ height: '12px' }} />
                                
                                {isDiv ? (
                                    <div style={{background:'#f8fafc', padding:'15px', border:'1px solid #374151', borderRadius:'4px'}}>
                                        <div style={{display:'flex', gap:'4px', marginBottom:'10px'}}>
                                            {words.map((w, i) => (
                                                <React.Fragment key={i}>
                                                    <span style={{padding:'6px 10px', background:'white', border:'1px solid #cbd5e1'}}>{w}</span>
                                                    {i < words.length - 1 && (
                                                        <button
                                                            onClick={() => setSelectedCuts(prev => prev.includes(i) ? prev.filter(x => x !== i) : [...prev, i].sort((a, b) => a - b))}
                                                            style={{width:'10px', background: selectedCuts.includes(i) ? '#374151' : '#e2e8f0', border:'none', cursor:'pointer'}}
                                                        />
                                                    )}
                                                </React.Fragment>
                                            ))}
                                        </div>
                                        <div style={{display:'flex', gap:'8px', justifyContent:'center'}}>
                                            <button onClick={handleDivide} className="btn btn-primary" style={{padding:'5px 12px'}}>Dividir</button>
                                            <button onClick={() => setDivisionMode(null)} className="btn btn-outline" style={{padding:'5px 12px'}}>Cancelar</button>
                                        </div>
                                    </div>
                                ) : (
	                                    <div className="node-box-row">
                                        <div
                                            className={`node-box ${canDivide ? 'can-divide' : ''}`}
                                            onClick={() => !hasC && canDivide && setDivisionMode(node.id)}
                                        >
                                            {node.text}
                                            {canConsolidate && (
                                                <button
                                                    className="consolidate-btn"
                                                    title={node.isConsolidated ? "Permitir división" : "Consolidar (no dividir)"}
                                                    onClick={(e) => { e.stopPropagation(); toggleConsolidated(node.id); }}
                                                >
                                                    {node.isConsolidated ? '÷' : '∪'}
                                                </button>
                                            )}
                                            {canExpand && (
                                                <button
                                                    className="consolidate-btn"
                                                    title="Expandir (agregar constituyentes)"
                                                    onClick={(e) => { e.stopPropagation(); expandNode(node.id); }}
                                                >
                                                    ÷
                                                </button>
                                            )}
                                            {hasC && !node.isInserted && (
                                                <button
                                                    className="add-node-btn"
                                                    title="Agregar nodo hijo"
                                                    onClick={(e) => { e.stopPropagation(); addChildNode(node.id); }}
                                                >
                                                    +
                                                </button>
                                            )}
                                            {hasC && (
                                                <button
                                                    className="clear-text-btn"
                                                    onClick={(e) => { e.stopPropagation(); setTree(prev => updateNode(prev, node.id, { text: '' })); }}
                                                >
                                                    ✕
                                                </button>
                                            )}
                                            {isTerminal && (
                                                <button
                                                    className={`nucleus-toggle-btn ${node.isNucleus ? 'is-nucleus' : ''}`}
                                                    title={node.isNucleus ? "Quitar negritas (núcleo)" : "Marcar como núcleo (negritas)"}
                                                    onClick={(e) => { 
                                                        e.stopPropagation(); 
                                                        setTree(prev => updateNode(prev, node.id, { isNucleus: !node.isNucleus })); 
                                                    }}
                                                >
                                                    N
                                                </button>
                                            )}
                                        </div>
                                        {hasC && (
                                            <button
                                                className="btn-danger-soft node-revert-btn"
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    setTree(prev => updateNode(prev, node.id, { children: null }));
                                                }}
                                                title="Deshacer división"
                                                aria-label="Deshacer división"
                                            >
                                                ↩
                                            </button>
                                        )}</div>
                                )}
                                
                                <div className="connector-v" style={{ height: '12px' }} />
                            </>
                        )}

                        {renderLabelInput(node, 'labelBottom', false)}
                        
                        {hasC && (
                            <div style={{display:'flex', flexDirection:'column', alignItems:'center', width:'100%'}}>
                                <div className="connector-v" style={{height:'24px'}} />
                                <div className="children-container">
                                    {node.children.map((c) => (
                                        <div className="child-branch" key={c.id}>
                                            <div className="v-line-stem" />
                                            {renderNode(c)}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                );
            };

            // ===========================================
            // RENDERIZADO ESTÁTICO (COMPARACIÓN)
            // ===========================================
            const renderStaticNode = (node, comparisons, path = 'root', isModel = false) => {
                const comparison = comparisons?.get(path);

                // Para el árbol del estudiante, si no hay nodo, no renderizamos nada
                // (ya no creamos nodos fantasma ∅)
                if (!node) return null;

                const isEmpty = !node.text || node.text.trim() === '';

                let nodeClass = 'node-container';
                if (node.isNucleus) nodeClass += ' nucleus-node';

                // Colorear el nodo según si fue IDENTIFICADO correctamente (no según división)
                // Un nodo verde significa que el estudiante identificó correctamente este constituyente
                if (!isModel && comparison) {
                    nodeClass += comparison.nodeCorrect ? ' node-correct' : ' node-incorrect';
                }

                const modelTop = comparison?.modelNode?.labelTop?.trim() || '';
                const modelBottom = comparison?.modelNode?.labelBottom?.trim() || '';
                const studentTop = (node.labelTop || '').trim();
                const studentBottom = (node.labelBottom || '').trim();

                const shouldShowTop = isModel ? !!studentTop : (!!studentTop || !!modelTop);
                const shouldShowBottom = isModel ? !!studentBottom : (!!studentBottom || !!modelBottom);

                const labelTopClass = (!isModel && comparison && (studentTop || modelTop))
                    ? (comparison.labelTopMatch ? 'label-correct' : 'label-incorrect')
                    : '';

                const labelBottomClass = (!isModel && comparison && (studentBottom || modelBottom))
                    ? (comparison.labelBottomMatch ? 'label-correct' : 'label-incorrect')
                    : '';

                const renderStaticLabel = (valueToShow, isTop, extraClass) => {
                    if (!valueToShow || !valueToShow.trim()) return null;
                    const showAsEmpty = valueToShow.trim() === '∅';
                    
                    // Formatear el valor para mostrar • en vez de / como separador
                    const displayValue = valueToShow.split('/').map(p => p.trim()).filter(p => p).join(' • ');

                    return (
                        <div
                            className={extraClass}
                            style={{
                                width: '95px',
                                textAlign: 'center',
                                padding: 'calc(4px * var(--ent-text-scale, 1))',
                                fontSize: 'calc(11px * var(--ent-text-scale, 1))',
                                borderRadius: '4px',
                                textTransform: isTop ? 'uppercase' : 'none',
                                fontStyle: showAsEmpty ? 'italic' : 'normal',
                                opacity: showAsEmpty ? 0.9 : 1,
                                backgroundColor: extraClass ? undefined : '#f1f5f9',
                                border: extraClass ? undefined : '1px solid #cbd5e1',
                                color: extraClass ? undefined : '#334155'
                            }}
                        >
                            {displayValue}
                        </div>
                    );
                };

                // Determinar qué hijos renderizar
                let childrenToRender = [];
                
                // Si es el modelo, o si la división es correcta, mostrar los hijos
                if (isModel || (comparison && comparison.divisionCorrect)) {
                    const children = node.children || [];
                    const normalizeLabel = (label) => {
                        if (!label) return '';
                        return label.split('/')
                            .map(p => p.trim().toLowerCase().replace(/\s+/g, ''))
                            .filter(p => p)
                            .sort()
                            .join('•');
                    };
                    
                    // Contar índices separados para nodos normales y extra
                    let normalIndex = 0;
                    let extraIndex = 0;
                    
                    if (isModel) {
                        // Para el modelo: recorrer en orden original, asignando paths según tipo
                        children.forEach((c) => {
                            if (c.isInserted) {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-e${extraIndex}`
                                });
                                extraIndex++;
                            } else {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-n${normalIndex}`
                                });
                                normalIndex++;
                            }
                        });
                    } else {
                        // Para el estudiante: recorrer en orden original, pero emparejar extras por etiquetas
                        const modelExtra = (comparison?.modelNode?.children || []).filter(c => c.isInserted);
                        
                        // Crear un mapa de etiquetas del modelo a índice
                        const modelExtraByLabels = new Map();
                        modelExtra.forEach((mc, mi) => {
                            const key = normalizeLabel(mc.labelTop) + '|' + normalizeLabel(mc.labelBottom);
                            if (!modelExtraByLabels.has(key)) {
                                modelExtraByLabels.set(key, mi);
                            }
                        });
                        
                        const usedModelExtraIndices = new Set();
                        
                        children.forEach((c) => {
                            if (c.isInserted) {
                                // Buscar el índice del modelo que corresponde a este nodo extra por etiquetas
                                const key = normalizeLabel(c.labelTop) + '|' + normalizeLabel(c.labelBottom);
                                let modelIdx = modelExtraByLabels.get(key);
                                
                                // Si ya se usó ese índice, buscar otro con las mismas etiquetas
                                if (modelIdx !== undefined && usedModelExtraIndices.has(modelIdx)) {
                                    modelIdx = undefined;
                                    for (let mi = 0; mi < modelExtra.length; mi++) {
                                        if (usedModelExtraIndices.has(mi)) continue;
                                        const mKey = normalizeLabel(modelExtra[mi].labelTop) + '|' + normalizeLabel(modelExtra[mi].labelBottom);
                                        if (mKey === key) {
                                            modelIdx = mi;
                                            break;
                                        }
                                    }
                                }
                                
                                if (modelIdx !== undefined) {
                                    usedModelExtraIndices.add(modelIdx);
                                    childrenToRender.push({ 
                                        node: c, 
                                        path: `${path}-e${modelIdx}`
                                    });
                                }
                            } else {
                                childrenToRender.push({ 
                                    node: c, 
                                    path: `${path}-n${normalIndex}`
                                });
                                normalIndex++;
                            }
                        });
                    }
                }
                // Si hay error de división (shouldTruncate), no mostramos hijos, solo el mensaje

                return (
                    <div className={nodeClass} key={node.id || path}>
                        {shouldShowTop && renderStaticLabel(
                            isModel ? studentTop : (studentTop || (modelTop ? '∅' : '')), 
                            true, 
                            labelTopClass
                        )}

                        {isEmpty ? (
                            <div className="connector-v" style={{ height: '36px' }} />
                        ) : (
                            <>
                                <div className="connector-v" style={{ height: '12px' }} />
                                <div className="node-box" style={{ cursor: 'default' }}>
                                    {node.text}
                                </div>
                                {/* Solo mostrar línea inferior si hay etiqueta inferior, hijos, o mensaje de error */}
                                {(shouldShowBottom || childrenToRender.length > 0 || (!isModel && comparison?.shouldTruncate)) && (
                                    <div className="connector-v" style={{ height: '12px' }} />
                                )}
                            </>
                        )}

                        {shouldShowBottom && renderStaticLabel(
                            isModel ? studentBottom : (studentBottom || (modelBottom ? '∅' : '')), 
                            false, 
                            labelBottomClass
                        )}

                        {/* Si hay error de división, mostrar mensaje y truncar */}
                        {!isModel && comparison?.shouldTruncate ? (
                            <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                <div className="connector-v" style={{ height: '24px' }} />
                                <div style={{
                                    padding: '8px 16px',
                                    backgroundColor: '#fef2f2',
                                    border: '2px solid #ef4444',
                                    borderRadius: '6px',
                                    color: '#b91c1c',
                                    fontSize: 'calc(12px * var(--ent-text-scale, 1) * 0.85)',
                                    lineHeight: 1.25,
                                    fontWeight: 'bold',
                                    whiteSpace: 'normal',
                                    wordBreak: 'break-word',
                                    textAlign: 'center',
                                    maxWidth: '150px',
                                    minWidth: '150px',
                                    boxShadow: '0 2px 4px rgba(0,0,0,0.05)'
                                }}>
                                    Constituyente dividido incorrecta­mente
                                </div>
                            </div>
                        ) : (
                            /* Si la división es correcta (o es el modelo), mostramos los hijos */
                            childrenToRender.length > 0 && (
                                <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', width: '100%' }}>
                                    <div className="connector-v" style={{ height: '24px' }} />
                                    <div className="children-container">
                                        {childrenToRender.map((item, i) => (
                                            <div className="child-branch" key={(item.node?.id) || item.path || i}>
                                                <div className="v-line-stem" />
                                                {renderStaticNode(item.node, comparisons, item.path, isModel)}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )
                        )}
                    </div>
                );
            };

            // ===========================================
            // COMPONENTE FOOTER
            // ===========================================
            const Footer = () => (
                <footer className="footer">
                    <p>Carlos González Vergara (<strong><a href="mailto:cgonzalv@uc.cl">cgonzalv@uc.cl</a></strong>)</p>
                    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer">
                        <img 
                            src="https://mirrors.creativecommons.org/presskit/buttons/88x31/svg/by-nc-nd.svg" 
                            alt="CC BY-NC-ND 4.0" 
                        />
                    </a>
                </footer>
            );

            // ===========================================
            // VISTA DE COMPARACIÓN
            // ===========================================
            if (showComparison && comparisonResults) {
                return (
                    <div className="container">
                        {/* Selector de idioma */}
                        <div className="language-selector">
                            <img src="spain-solid.png" alt="Español" className="language-flag active" title="Español (actual)" />
                            <a href="english.html">
                                <img src="uk_grey.png" alt="English" className="language-flag inactive" title="Switch to English" />
                            </a>
                        </div>
                        <header className="header-logo-container">
                            <img src="ent_logo.png" alt="ENT - Asistente para el análisis sintáctico" className="header-logo" />
                        </header>

                        <div className="exercise-banner">
                            <div className="exercise-banner-text">
                                
                                <div>
                                    <div className="exercise-badge">📚 <strong>Modo ejercitación</strong></div>
                                    <p>Estás viendo los resultados. Puedes volver a editar o salir del modo ejercitación.</p>
                                </div>
                            </div>
                            <button onClick={resetExercise} className="btn btn-outline">Salir del modo ejercitación</button>
                        </div>

                        <div className="results-summary">
                            <h3>Resultados</h3>
                            <div className="results-stats" style={{ marginBottom: '14px' }}>
                                <div className="stat-item">
                                    <span className="stat-dot correct"></span>
                                    <strong>Aciertos:</strong>&nbsp;
                                    {comparisonResults.correctElements} / {comparisonResults.totalElements}
                                </div>
                                <div className="stat-item">
                                    <span className="stat-dot incorrect"></span>
                                    <strong>Errores:</strong>&nbsp;
                                    {comparisonResults.errorElements}
                                </div>
                                <div className="stat-item">
                                    <span className="stat-dot partial"></span>
                                    <strong>Porcentaje de acierto:</strong>&nbsp;
                                    {(comparisonResults.accuracy * 100).toFixed(0)}%
                                </div>
                            </div>
                            <p style={{margin: 0, fontSize: '15px', color: '#374151', lineHeight: '1.6'}}>
                                <ul>
                                    <li>Los constituyentes en <span style={{color: '#10b981'}}>verde</span> tienen estructura correcta; 
                                    los que están en <span style={{color: '#ef4444'}}>rojo</span> presentan diferencias estructurales. </li>
                                    <li>Las etiquetas en <span style={{color: '#10b981'}}>verde</span> tienen información correcta;
                                    las de <span style={{color: '#ef4444'}}>rojo</span> tienen información que difiere del modelo.  </li>
                                </ul>
                            </p>
                        </div>

                        <div className="comparison-container">
                            <div className="comparison-panel student">
                                <h3>✎ Tu análisis</h3>
                                <div className="comparison-tree">
                                    {/* Controles de zoom para panel estudiante con wrapper sticky */}
                                    <div className="zoom-controls-wrapper">
                                        <div className={`zoom-controls visible`}>
                                            <button 
                                                className="zoom-btn" 
                                                onClick={studentZoomOut} 
                                                disabled={studentZoomLevel <= ZOOM_MIN}
                                                title="Alejar"
                                            >
                                                −
                                            </button>
                                            <div 
                                                className="zoom-indicator" 
                                                onClick={studentZoomReset}
                                                title="Restablecer zoom"
                                            >
                                                {studentZoomLevel}%
                                            </div>
                                            <button 
                                                className="zoom-btn" 
                                                onClick={studentZoomIn} 
                                                disabled={studentZoomLevel >= ZOOM_MAX}
                                                title="Acercar"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </div>
                                    <div 
                                        className="zoom-container"
                                        ref={studentZoomContainerRef}
                                        style={{ zoom: studentZoomLevel / 100, '--ent-text-scale': studentTextScale }}
                                    >
                                        <div className="tree-wrapper">
                                            {renderStaticNode(tree, comparisonResults.nodeComparisons, 'root', false)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div className="comparison-panel model">
                                <h3>✓ Análisis modelo</h3>
                                <div className="comparison-tree">
                                    {/* Controles de zoom para panel modelo con wrapper sticky */}
                                    <div className="zoom-controls-wrapper">
                                        <div className={`zoom-controls visible`}>
                                            <button 
                                                className="zoom-btn" 
                                                onClick={modelZoomOut} 
                                                disabled={modelZoomLevel <= ZOOM_MIN}
                                                title="Alejar"
                                            >
                                                −
                                            </button>
                                            <div 
                                                className="zoom-indicator" 
                                                onClick={modelZoomReset}
                                                title="Restablecer zoom"
                                            >
                                                {modelZoomLevel}%
                                            </div>
                                            <button 
                                                className="zoom-btn" 
                                                onClick={modelZoomIn} 
                                                disabled={modelZoomLevel >= ZOOM_MAX}
                                                title="Acercar"
                                            >
                                                +
                                            </button>
                                        </div>
                                    </div>
                                    <div 
                                        className="zoom-container"
                                        ref={modelZoomContainerRef}
                                        style={{ zoom: modelZoomLevel / 100, '--ent-text-scale': modelTextScale }}
                                    >
                                        <div className="tree-wrapper">
                                            {renderStaticNode(modelTree, null, 'root', true)}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="bottom-actions">
                            <button onClick={() => setShowComparison(false)} className="btn btn-outline">← Volver a editar</button>
                            <button onClick={newExercise} className="btn btn-primary">Nuevo ejercicio</button>
                        </div>

                        <Footer />
                    </div>
                );
            }

            // ===========================================
            // VISTA PRINCIPAL
            // ===========================================
            return (
                <div className="container">
                    <div className="language-selector">
                            <img src="spain-solid.png" alt="Español" className="language-flag active" title="Español (actual)" />
                            <a href="english.html">
                                <img src="uk_grey.png" alt="English" className="language-flag inactive" title="Switch to English" />
                            </a>
                        </div>
                    <header className="header-logo-container">
                        <img src="ent_logo.png" alt="ENT - Asistente para el análisis sintáctico" className="header-logo" />
                    </header>

                    {exerciseMode && !modelTree && (
                        <div className="exercise-banner" style={{flexDirection: 'column', alignItems: 'center', padding: '40px'}}>
                            <div className="exercise-banner-text">
                                
                                <div>
                                    <div className="exercise-badge">📚 <strong>Modo ejercitación</strong></div>
                                    <p>Analiza la expresión y compara tu resultado con el modelo cuando termines</p>
                                </div>
                            </div>
                            <p style={{marginBottom: '16px', color: '#6b7280'}}>Selecciona un ejercicio desde tu computador o desde el banco de ejemplos</p>
                            
                            <div style={{display: 'flex', gap: '12px', marginBottom: '16px'}}>
                                <button onClick={() => exerciseInputRef.current.click()} className="btn btn-primary">📂 Cargar archivo local</button>
                                <button onClick={() => { setShowFilesModal(true); setFilesActiveTab('cloud'); }} className="btn btn-primary">☁️ Banco de ejemplos</button>
                            </div>
                            
                            {driveFiles.length > 0 && (
                                <div style={{width: '100%', maxWidth: '500px', marginBottom: '16px'}}>
                                    <div className="drive-files-list" style={{maxHeight: '200px'}}>
                                        {driveFiles.map((folder, idx) => (
                                            folder.folderName ? (
                                                <div className="drive-folder" key={folder.folderId || idx}>
                                                    <div 
                                                        className="drive-folder-header"
                                                        onClick={() => toggleFolder(folder.folderId)}
                                                    >
                                                        <span className={`drive-folder-toggle ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>▼</span>
                                                        📁 {folder.folderName}
                                                        <span style={{marginLeft: 'auto', fontSize: '11px', color: '#9ca3af'}}>
                                                            {folder.files.length} archivo{folder.files.length !== 1 ? 's' : ''}
                                                        </span>
                                                    </div>
                                                    <div className={`drive-folder-content ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>
                                                        {folder.files.map(file => (
                                                            <div 
                                                                key={file.id}
                                                                className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                onClick={() => setSelectedDriveFile(file)}
                                                            >
                                                                <span className="drive-file-icon">📄</span>
                                                                <span className="drive-file-name">{file.name}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                </div>
                                            ) : (
                                                <div className="drive-root-files" key="root">
                                                    {folder.files.map(file => (
                                                        <div 
                                                            key={file.id}
                                                            className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                            onClick={() => setSelectedDriveFile(file)}
                                                        >
                                                            <span className="drive-file-icon">📄</span>
                                                            <span className="drive-file-name">{file.name}</span>
                                                        </div>
                                                    ))}
                                                </div>
                                            )
                                        ))}
                                    </div>
                                    {selectedDriveFile && (
                                        <div style={{marginTop: '12px', textAlign: 'center'}}>
                                            <button 
                                                className="btn btn-exercise"
                                                onClick={() => handleLoadFromDrive(true)}
                                            >
                                                📚 Iniciar ejercicio con "{selectedDriveFile.name}"
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}
                            
                            <button onClick={resetExercise} className="btn btn-outline">Salir del modo ejercitación</button>
                        </div>
                    )}

                    {exerciseMode && modelTree && (
                        <div className="exercise-banner">
                            <div className="exercise-banner-text">
                                <div>
                                    <div className="exercise-badge">📚 <strong>Modo ejercitación</strong></div>
                                    <p>Analiza la expresión y compara tu resultado con el modelo cuando termines</p>
                                </div>
                            </div>
                            <button onClick={resetExercise} className="btn btn-outline">Salir del modo ejercitación</button>
                        </div>
                    )}

                    <div className="input-section">
                        <div className="input-row">
                            {!exerciseMode ? (
                                <>
                                    <input 
                                        type="text" 
                                        value={sentence} 
                                        onChange={(e) => setSentence(e.target.value)} 
                                        placeholder="Escribe la expresión que quieres analizar" 
                                        onKeyPress={(e) => e.key === 'Enter' && startAnalysis()} 
                                    />
                                    <div className="analyze-undo-group">
                                        <button onClick={startAnalysis} className="btn btn-primary">Analizar</button>
                                        <button 
                                            onClick={handleUndo} 
                                            className="btn btn-outline btn-icon" 
                                            disabled={!canUndo}
                                            title="Deshacer (Ctrl+Z)"
                                        >
                                            ↶
                                        </button>
                                        <button 
                                            onClick={handleRedo} 
                                            className="btn btn-outline btn-icon" 
                                            disabled={!canRedo}
                                            title="Rehacer (Ctrl+Shift+Z)"
                                        >
                                            ↷
                                        </button>
                                    </div>
                                    <span className="btn-separator"></span>
                                    <button onClick={() => setShowFilesModal(true)} className="btn btn-outline">📁 Archivos</button>
                                    <input type="file" ref={fileInputRef} style={{display:'none'}} accept=".ent,.json,application/json,text/plain,*/*" onChange={handleLoadJSON} />
                                    <span className="btn-separator"></span>
                                    <button onClick={() => setExerciseMode(true)} className="btn btn-exercise">📚 Modo ejercitación</button>
                                    <span className="btn-separator"></span>
                                    <button 
                                        onClick={() => window.open('manual.html', '_blank')} 
                                        className="btn btn-outline"
                                        title="Consultar manual detallado"
                                    >
                                        🗂 Manual
                                    </button>
                                </>
                            ) : (
                                modelTree && (
                                    <div style={{flex: 1, padding: '8px 16px', backgroundColor: '#f3f4f6', borderRadius: '6px', fontSize: '15px', color: '#374151'}}>
                                        <strong>Expresión que debes analizar:</strong> {sentence}
                                    </div>
                                )
                            )}
                        </div>
                        <input type="file" ref={exerciseInputRef} style={{display:'none'}} accept=".ent,.json,application/json,text/plain,*/*" onChange={handleLoadExercise} />
                    </div>

                    {!(exerciseMode && !modelTree) && (
                        <div className="tree-container" ref={treeContainerRef}>
                            <div className={`autosave-indicator ${(isSaving || lastSaved) ? 'visible' : ''}`}>
                                <span className={`autosave-dot ${isSaving ? 'saving' : ''}`}></span>
                                <span className="autosave-text">
                                    {isSaving ? (
                                        <>
                                            Autoguardando
                                            <span className="autosave-ellipsis" aria-hidden="true">
                                                <span>.</span><span>.</span><span>.</span>
                                            </span>
                                        </>
                                    ) : (lastSaved ? `Guardado ${formatTimeAgo(lastSaved)}` : '')}
                                </span>
                            </div>

                            {/* Controles de zoom con wrapper sticky */}
                            <div className="zoom-controls-wrapper">
                                <div className={`zoom-controls ${tree ? 'visible' : ''}`}>
                                    <button 
                                        className="zoom-btn" 
                                        onClick={zoomOut} 
                                        disabled={zoomLevel <= ZOOM_MIN}
                                        title="Alejar (Ctrl/⌘ + −)"
                                    >
                                        −
                                    </button>
                                    <div 
                                        className="zoom-indicator" 
                                        onClick={zoomReset}
                                        title="Restablecer zoom (Ctrl/⌘ + 0)"
                                    >
                                        {zoomLevel}%
                                    </div>
                                    <button 
                                        className="zoom-btn" 
                                        onClick={zoomIn} 
                                        disabled={zoomLevel >= ZOOM_MAX}
                                        title="Acercar (Ctrl/⌘ + +)"
                                    >
                                        +
                                    </button>
                                </div>
                            </div>
                            
                            {tree ? (
                                <div 
                                    className="zoom-container"
                                    ref={zoomContainerRef}
                                        style={{ zoom: zoomLevel / 100, '--ent-text-scale': textScale }}
                                >
                                    <div className="tree-wrapper">{renderNode(tree)}</div>
                                </div>
                            ) : (
                                <p style={{textAlign:'center', color:'#9ca3af', marginTop:'100px'}}>
                                    <strong>Escribe una expresión</strong> o carga un archivo .ent en <strong>Archivos</strong> para editarlo
                                </p>
                            )}
                        </div>
                    )}

                    {tree && (
                        <div className="bottom-actions">
                            {exerciseMode ? (
                                <>
                                    <button onClick={newExercise} className="btn btn-outline">Cancelar ejercicio</button>
                                    <button onClick={handleFinishExercise} className="btn btn-success">✓ Terminar análisis y comparar</button>
                                </>
                            ) : (
                                <>
                                    <button onClick={() => { setTree(null); setSentence(''); setHistory([]); setHistoryIndex(-1); localStorage.removeItem('ent-autosave'); setLastSaved(null); }} className="btn btn-new-analysis">✦ Nuevo análisis</button>
                                    <button onClick={handleSaveJSON} className="btn btn-outline" disabled={!tree} title="Save (Ctrl+S)">💾 Guardar .ent</button>
                                    <button onClick={() => handleExport(false)} className="btn btn-primary">Exportar diagrama</button>
                                    <button onClick={() => handleExport(true)} className="btn btn-primary">Exportar diagrama arbóreo</button>
                                </>
                            )}
                        </div>
                    )}

                    <div className="instructions-panel">
                        <div 
                            className="instructions-header" 
                            onClick={() => setInstructionsCollapsed(!instructionsCollapsed)}
                        >
                            <span>Guía rápida</span>
                            <span className={`instructions-toggle ${instructionsCollapsed ? 'collapsed' : ''}`}>▼</span>
                        </div>
                        <div className={`instructions-content ${instructionsCollapsed ? 'collapsed' : ''}`}>
                            <div className="instructions-grid">
                                
                                <div className="instruction-card">
                                    <h4><span className="icon">✂</span> Constituyentes</h4>
                                    <ul>
                                        <li>Haz clic en un <strong>recuadro celeste</strong> para dividir una estructura sintáctica en constituyentes.</li>
                                        <li>Haz clic en las <strong>barras grises</strong> entre palabras para marcar fronteras entre constituyentes.</li>
                                        <li>Haz clic en <code>↩</code> junto a un recuadro celeste para revertir la división.</li>
                                        <li>Haz clic en la <code>⨉</code> roja si quieres eliminar el texto de un nodo y mantener solo las etiquetas.</li>
                                        <li>Pasa el cursor por un nodo terminal (palabra) y pulsa <code>N</code> para marcarlo como <strong>núcleo</strong> (negritas).</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">☖</span> Etiquetas</h4>
                                    <ul>
                                        <li>En la etiqueta <strong>superior</strong> escribe la función sintáctica (Suj, CD, CI, N, Det, etc.).</li>
                                        <li>En la etiqueta <strong>inferior</strong> escribe la categoría (sust, v, SN, SV, etc.).</li>
                                        <li>Si lo prefieres, haz clic en <code>☰</code> para seleccionar etiquetas predefinidas.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">⇄</span> Dividir etiquetas</h4>
                                    <ul>
                                        <li>Pasa el cursor por la etiqueta y pulsa <code>⇄</code> para dividir o unir.</li>
                                        <li>Útil para análisis con múltiples funciones o categorías.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">＋</span> Agregar constituyentes extra</h4>
                                    <ul>
                                        <li>Pasa el cursor por el nodo bajo el cual quieres crear un constituyente extra y haz clic en <code>+</code>.</li>
                                        <li>Escribe el texto y elige la posición donde insertarlo.</li>
                                        <li>Útil para añadir constituyentes elididos.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">Aa</span> Formato de texto</h4>
                                    <ul>
                                        <li><code>*texto*</code> para <em>cursivas</em></li>
                                        <li><code>**texto**</code> para <strong>negritas</strong></li>
                                        <li><code>_texto_</code> para <sub>subíndice</sub></li>
                                        <li><code>¨texto¨</code> para <sup>superíndice</sup></li>
                                    </ul>
                                </div> 

                                <div className="instruction-card">
                                    <h4><span className="icon">⌘</span> Atajos de teclado</h4>
                                            <div style={{ display: 'flex', justifyContent: 'flex-start', gap: '40px', marginTop: '8px' }}>
                                            <ul className="shortcut-list">
                                                <li style={{ marginBottom: '10px', opacity: 0.7, fontSize: '11px', fontWeight: 'bold',
                                    whiteSpace: 'normal',
                                    wordBreak: 'break-word', color: '#6b7280' }}>WINDOWS / LINUX</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">Z</span> Deshacer</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">Y</span> Rehacer</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">S</span> Guardar</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">+</span> Acercar</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">−</span> Alejar</li>
                                                <li><span className="key">Ctrl</span>+<span className="key">0</span> Restablecer zoom</li>
                                            </ul>

                                            <ul className="shortcut-list">
                                                <li style={{ marginBottom: '10px', opacity: 0.7, fontSize: '11px', fontWeight: 'bold',
                                    whiteSpace: 'normal',
                                    wordBreak: 'break-word', color: '#6b7280' }}>macOS</li>
                                                <li><span className="key">⌘</span>+<span className="key">Z</span> Deshacer</li>
                                                <li><span className="key">⌘</span>+<span className="key">⇧</span>+<span className="key">Z</span> Rehacer</li>
                                                <li><span className="key">⌘</span>+<span className="key">S</span> Guardar</li>
                                                <li><span className="key">⌘</span>+<span className="key">+</span> Acercar</li>
                                                <li><span className="key">⌘</span>+<span className="key">−</span> Alejar</li>
                                                <li><span className="key">⌘</span>+<span className="key">0</span> Restablecer zoom</li>
                                            </ul>
                                        </div>
                                </div>
                                
                                <div className="instruction-card">
                                    <h4><span className="icon">⌕</span> Zoom</h4>
                                    <ul>
                                        <li>Usa los botones <code>[−]</code> y <code>[+]</code> en la esquina superior derecha para alejar/acercar.</li>
                                        <li>Haz clic en el porcentaje para restablecer al 100%.</li>
                                        <li>Rango de zoom: 40% a 200% en incrementos de 20%.</li>
                                        <li>Los controles aparecen cuando hay un diagrama presente.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">∪</span> Consolidar nodos</h4>
                                    <ul>
                                        <li>Pasa el cursor por un nodo celeste y pulsa <code>∪</code> para consolidarlo.</li>
                                        <li>Útil para perífrasis verbales o locuciones, que no deben dividirse sintácticamente.</li>
                                        <li>Pulsa <code>÷</code> para volver a permitir la división.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">÷</span> Expandir nodos</h4>
                                    <ul>
                                        <li>Pasa el cursor por un nodo terminal y pulsa <code>÷</code> para expandirlo.</li>
                                        <li>Se crea un hijo con el mismo texto. Usa <code>+</code> para agregar constituyentes extra.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">◰</span> Archivos</h4>
                                    <ul>
                                        <li>Haz clic en <strong>📁 Archivos</strong> para abrir el gestor de archivos.</li>
                                        <li>Pestaña <strong>Local</strong>: guarda o carga archivos <code>.ent</code> desde tu computador.</li>
                                        <li>Pestaña <strong>Banco de ejemplos</strong>: conecta con Google Drive para acceder a ejemplos compartidos.</li>
                                        <li><strong>Autoguardado</strong>: ENT guarda tu trabajo automáticamente (cada ~3 s). Si cierras la pestaña, al volver podrás restaurarlo.</li>
                                        <li>Atajo: <span className="key">Ctrl</span>/<span className="key">⌘</span>+<span className="key">S</span> guarda directamente.</li>
                                    </ul>
                                </div>

                                <div className="instruction-card">
                                    <h4><span className="icon">☷</span> Banco de ejemplos</h4>
                                    <ul>
                                        <li>Para crear un banco de ejemplos, sube archivos <code>.ent</code> a una carpeta de Google Drive.</li>
                                        <li>Haz clic derecho en la carpeta → <strong>Compartir</strong> → <strong>Cualquier persona con el enlace</strong> (como Lector).</li>
                                        <li>Copia el enlace y compártelo con tus estudiantes.</li>
                                        <li>Puedes organizar los ejemplos en subcarpetas (por tema, dificultad, etc.).</li>
                                    </ul>
                                </div>

                                {!exerciseMode && (
                                <div className="instruction-card">
                                    <h4><span className="icon">✎</span> Modo ejercitación</h4>
                                    <ul>
                                        <li>Haz clic en <strong>📚 Modo ejercitación</strong> para practicar.</li>
                                        <li>Carga un ejercicio desde tu computador o desde un <strong>banco de ejemplos</strong> en Google Drive.</li>
                                        <li>Analiza la expresión propuesta y compara tu resultado con el modelo.</li>
                                    </ul>
                                </div>
                                )}

                                {exerciseMode && (
                                <div className="instruction-card">
                                    <h4 style={{color: '#5b21b6'}}><span className="icon" style={{backgroundColor: '#5b21b6'}}>✎</span> Ejercicio activo</h4>
                                    <ul>
                                        <li>Completa el análisis de la expresión.</li>
                                        <li>Usa <strong>Comparar</strong> para ver la solución.</li>
                                    </ul>
                                </div>
                                )}

                            </div>
                        </div>
                    </div>

                    {showFilesModal && (
                        <div className="pos-overlay" onClick={() => setShowFilesModal(false)}>
                            <div className="files-modal" onClick={(e) => e.stopPropagation()}>
                                <div className="files-modal-header">
                                    <h4 className="files-modal-title">{exerciseMode ? '☁️ Banco de ejemplos' : '📁 Archivos'}</h4>
                                    {!exerciseMode && (
                                        <div className="files-tabs">
                                            <button 
                                                className={`files-tab ${filesActiveTab === 'local' ? 'active' : ''}`}
                                                onClick={() => setFilesActiveTab('local')}
                                            >
                                                💻 Local
                                            </button>
                                            <button 
                                                className={`files-tab ${filesActiveTab === 'cloud' ? 'active' : ''}`}
                                                onClick={() => setFilesActiveTab('cloud')}
                                            >
                                                ☁️ Banco de ejemplos
                                            </button>
                                        </div>
                                    )}
                                </div>

                                <div className="files-modal-body">
                                    {!exerciseMode && filesActiveTab === 'local' && (
                                        <div className="files-section">
                                            <div className="files-section-title">Gestión de archivos locales</div>
                                            <div className="files-btn-row">
                                                <button 
                                                    onClick={() => { fileInputRef.current.click(); setShowFilesModal(false); }} 
                                                    className="btn btn-outline"
                                                >
                                                    📂 Cargar .ent
                                                </button>
                                                <button 
                                                    onClick={() => { handleSaveJSON(); setShowFilesModal(false); }} 
                                                    className="btn btn-primary" 
                                                    disabled={!tree}
                                                    title="Guardar (Ctrl+S)"
                                                >
                                                    💾 Guardar .ent
                                                </button>
                                            </div>
                                            <p className="files-help-text">
                                                Los archivos <code>.ent</code> guardan tu análisis completo (expresión, estructura y etiquetas).
                                            </p>
                                        </div>
                                    )}

                                    {(exerciseMode || filesActiveTab === 'cloud') && (
                                        <div className="files-section">
                                            <div className="files-section-title">Conectar con Google Drive</div>
                                            <div className="drive-connect-row">
                                                <input 
                                                    type="text"
                                                    className="drive-url-input"
                                                    placeholder="URL de carpeta de Google Drive..."
                                                    value={driveUrl}
                                                    onChange={(e) => setDriveUrl(e.target.value)}
                                                    onKeyPress={(e) => e.key === 'Enter' && handleConnectDrive()}
                                                />
                                                <button 
                                                    className="btn btn-primary" 
                                                    onClick={handleConnectDrive}
                                                    disabled={!driveUrl.trim()}
                                                >
                                                    Conectar
                                                </button>
                                            </div>
                                            <p className="files-help-text">
                                                Pega la URL de una carpeta pública de Google Drive que contenga archivos <code>.ent</code>.<br/>
                                                La carpeta debe estar compartida como "Cualquier persona con el enlace".<br/><br/>
                                                ¿No tienes una carpeta o un enlace? Prueba con el <a 
                                                    href="#" 
                                                    onClick={(e) => {
                                                        e.preventDefault();
                                                        setDriveUrl('https://drive.google.com/drive/folders/1faSpC1f2qUUJag87xRVKuJf2VBk--d7r?usp=share_link');
                                                        setTimeout(() => handleConnectDrive(), 100);
                                                    }}
                                                    style={{color: '#3b82f6', textDecoration: 'underline', cursor: 'pointer'}}
                                                >banco de ejemplos de ENT</a>.
                                            </p>

                                            {driveStatus.type && (
                                                <div className={`drive-status ${driveStatus.type}`}>
                                                    {driveStatus.type === 'loading' && <div className="drive-spinner"></div>}
                                                    {driveStatus.type === 'error' && <span>⚠️</span>}
                                                    {driveStatus.type === 'success' && <span>✓</span>}
                                                    <span>{driveStatus.message}</span>
                                                </div>
                                            )}

                                            {driveFiles.length > 0 && (
                                                <>
                                                    <div className="files-section-title" style={{marginTop: '16px'}}>Archivos disponibles</div>
                                                    <div className="drive-files-list">
                                                        {driveFiles.map((folder, idx) => (
                                                            folder.folderName ? (
                                                                <div className="drive-folder" key={folder.folderId || idx}>
                                                                    <div 
                                                                        className="drive-folder-header"
                                                                        onClick={() => toggleFolder(folder.folderId)}
                                                                    >
                                                                        <span className={`drive-folder-toggle ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>▼</span>
                                                                        📁 {folder.folderName}
                                                                        <span style={{marginLeft: 'auto', fontSize: '11px', color: '#9ca3af'}}>
                                                                            {folder.files.length} archivo{folder.files.length !== 1 ? 's' : ''}
                                                                        </span>
                                                                    </div>
                                                                    <div className={`drive-folder-content ${collapsedFolders[folder.folderId] ? 'collapsed' : ''}`}>
                                                                        {folder.files.map(file => (
                                                                            <div 
                                                                                key={file.id}
                                                                                className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                                onClick={() => setSelectedDriveFile(file)}
                                                                            >
                                                                                <span className="drive-file-icon">📄</span>
                                                                                <span className="drive-file-name">{file.name}</span>
                                                                            </div>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            ) : (
                                                                <div className="drive-root-files" key="root">
                                                                    {folder.files.map(file => (
                                                                        <div 
                                                                            key={file.id}
                                                                            className={`drive-file-item ${selectedDriveFile?.id === file.id ? 'selected' : ''}`}
                                                                            onClick={() => setSelectedDriveFile(file)}
                                                                        >
                                                                            <span className="drive-file-icon">📄</span>
                                                                            <span className="drive-file-name">{file.name}</span>
                                                                        </div>
                                                                    ))}
                                                                </div>
                                                            )
                                                        ))}
                                                    </div>

                                                    {selectedDriveFile && (
                                                        <div className="drive-load-options">
                                                            {!exerciseMode && (
                                                                <button 
                                                                    className="btn btn-outline"
                                                                    onClick={() => handleLoadFromDrive(false)}
                                                                >
                                                                    📖 Cargar como referencia
                                                                </button>
                                                            )}
                                                            <button 
                                                                className="btn btn-exercise"
                                                                onClick={() => handleLoadFromDrive(true)}
                                                            >
                                                                📚 Cargar como ejercicio
                                                            </button>
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                    )}
                                </div>

                                <div className="files-modal-footer">
                                    <button className="btn btn-outline" onClick={() => setShowFilesModal(false)}>Cerrar</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {posPicker && (
                        <div className="pos-overlay" onClick={() => setPosPicker(null)}>
                            <div className="pos-modal" onClick={(e) => e.stopPropagation()}>
                                <h4 className="pos-title">¿Dónde quieres el nuevo constituyente?</h4>
                                <p className="pos-sub">Elige la posición para insertarlo entre los constituyentes actuales.</p>
                                <div className="pos-row">
                                    <select
                                        className="pos-select"
                                        value={posPicker.pos}
                                        onChange={(e) => setPosPicker(pp => ({ ...pp, pos: parseInt(e.target.value, 10) }))}
                                    >
                                        {Array.from({ length: posPicker.siblings.length + 1 }, (_, idx) => {
                                            const i = idx + 1;
                                            return (
                                                <option key={i} value={i}>{buildPosLabel(i, posPicker.siblings)}</option>
                                            );
                                        })}
                                    </select>
                                </div>
                                <div className="pos-actions">
                                    <button className="btn btn-outline" onClick={() => setPosPicker(null)}>Cancelar</button>
                                    <button className="btn btn-primary" onClick={confirmInsertAtPosition}>Insertar</button>
                                </div>
                            </div>
                        </div>
                    )}

                    <Footer />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SyntaxTreeBuilder />);
    </script>
</body>
</html>